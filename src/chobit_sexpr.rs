// Copyright (C) 2022 Hironori Ishibashi
//
// This work is free. You can redistribute it and/or modify it under the
// terms of the Do What The Fuck You Want To Public License, Version 2,
// as published by Sam Hocevar. See below for more details.
//
// --------------------------------------------------------------------
//
//            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//                    Version 2, December 2004
//
// Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
//
// Everyone is permitted to copy and distribute verbatim or modified
// copies of this license document, and changing it is allowed as long
// as the name is changed.
//
//            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
//
//  0. You just DO WHAT THE FUCK YOU WANT TO.

#![allow(dead_code)]

//! Structured byte string library.
//!
//! This library needs `alloc` crate.
//!
//! ```ignore
//! extern crate alloc;
//! ```
//!
//! # Structure of ChobitSexpr
//!
//! There are 2 types of [ChobitSexpr].  
//! One type is __Atom__ , another is __Cons__ .
//!
//! ## Atom
//!
//! __Atom__ consists of [SexprHeader] and payload.
//!
//! | Position | Contents |
//! |-|-|
//! | The first of 4 bytes | [SexprHeader]. That contains atom flag and a size of payload in __little endian__ . |
//! | The rest of bytes | Payload. That contains byte data. |
//!
//! ## Cons
//!
//! __Cons__ consists of [SexprHeader] and __car__ and __cdr__.  
//! __Car__ and __cdr__ are [ChobitSexpr].
//!
//! | Position | Contents |
//! |-|-|
//! | The first of 4 bytes | [SexprHeader]. That contains cons flag and a size of car in __little endian__ . |
//! | Next bytes that size is written in header | [ChobitSexpr]. That is called __car__. |
//! | The rest of bytes | [ChobitSexpr]. That is called __cdr__. |
//!
//! # ChobitSexpr for ReScript
//!
//! Usage is written in 'ChobitSexpr.resi'
//!
//! - <a href="data:text/plain;base64,dHlwZSBzZXhwckhlYWRlciA9IHwgQGFzKDApIE5pbCB8IEBhcygxKSBBdG9tKGludCkgfCBAYXMoMikgQ29ucyhpbnQpCnR5cGUgY2hvYml0U2V4cHIgPSBVaW50OEFycmF5LnQKdHlwZSBzZXhwckRhdGFWaWV3ID0gRGF0YVZpZXcudAp0eXBlIHJlYyBjaG9iaXRTZXhwckJ1ZiA9CiAgfCBAYXMoMCkgRW1wdHkKICB8IEBhcygxKSBDb21wbGV0ZWQoY2hvYml0U2V4cHIpCiAgfCBAYXMoMikgQ2FyCiAgfCBAYXMoMykgQ2RyKGNob2JpdFNleHByKQogIHwgQGFzKDQpIExpc3QoYXJyYXk8Y2hvYml0U2V4cHI+KQoKbGV0IGZyb21VaW50OEFycmF5OiBVaW50OEFycmF5LnQgPT4gY2hvYml0U2V4cHIgPQogIChhcnkpID0+IGFyeS0+VHlwZWRBcnJheS5zbGljZVRvRW5kKH5zdGFydCA9IDApCgpsZXQgdG9VaW50OEFycmF5OiBjaG9iaXRTZXhwciA9PiBVaW50OEFycmF5LnQgPQogIChzZXhwcikgPT4gc2V4cHItPlR5cGVkQXJyYXkuc2xpY2VUb0VuZCh+c3RhcnQgPSAwKQoKbGV0IGZyb21CdWZmZXI6IChBcnJheUJ1ZmZlci50LCBpbnQsIGludCkgPT4gY2hvYml0U2V4cHIgPQogIChidWYsIG9mZnNldCwgbGVuKSA9PiBVaW50OEFycmF5LmZyb21CdWZmZXJXaXRoUmFuZ2UoCiAgICBidWYsCiAgICB+Ynl0ZU9mZnNldCA9IG9mZnNldCwKICAgIH5sZW5ndGggPSBsZW4KICApCgpsZXQgYnVmZmVyOiBjaG9iaXRTZXhwciA9PiAoQXJyYXlCdWZmZXIudCwgaW50LCBpbnQpID0KICAoc2V4cHIpID0+ICgKICAgIHNleHByLT5UeXBlZEFycmF5LmJ1ZmZlciwKICAgIHNleHByLT5UeXBlZEFycmF5LmJ5dGVPZmZzZXQsCiAgICBzZXhwci0+VHlwZWRBcnJheS5sZW5ndGgKICApCgpAc2VuZCBleHRlcm5hbCBvdmVyd3JpdGU6IChVaW50OEFycmF5LnQsIFVpbnQ4QXJyYXkudCwgaW50KSA9PiB1bml0ID0gInNldCIKCkBzZW5kIGV4dGVybmFsIGdldEk4Q29yZTogKERhdGFWaWV3LnQsIGludCwgYm9vbCkgPT4gaW50ID0gImdldEludDgiCkBzZW5kIGV4dGVybmFsIHNldEk4Q29yZTogKERhdGFWaWV3LnQsIGludCwgaW50LCBib29sKSA9PiB1bml0ID0gInNldEludDgiCkBzZW5kIGV4dGVybmFsIGdldFU4Q29yZTogKERhdGFWaWV3LnQsIGludCwgYm9vbCkgPT4gaW50ID0gImdldFVpbnQ4IgpAc2VuZCBleHRlcm5hbCBzZXRVOENvcmU6IChEYXRhVmlldy50LCBpbnQsIGludCwgYm9vbCkgPT4gdW5pdCA9ICJzZXRVaW50OCIKQHNlbmQgZXh0ZXJuYWwgZ2V0STE2Q29yZTogKERhdGFWaWV3LnQsIGludCwgYm9vbCkgPT4gaW50ID0gImdldEludDE2IgpAc2VuZCBleHRlcm5hbCBzZXRJMTZDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBpbnQsIGJvb2wpID0+IHVuaXQgPSAic2V0SW50MTYiCkBzZW5kIGV4dGVybmFsIGdldFUxNkNvcmU6IChEYXRhVmlldy50LCBpbnQsIGJvb2wpID0+IGludCA9ICJnZXRVaW50MTYiCkBzZW5kIGV4dGVybmFsIHNldFUxNkNvcmU6IChEYXRhVmlldy50LCBpbnQsIGludCwgYm9vbCkgPT4gdW5pdCA9ICJzZXRVaW50MTYiCkBzZW5kIGV4dGVybmFsIGdldEkzMkNvcmU6IChEYXRhVmlldy50LCBpbnQsIGJvb2wpID0+IGludCA9ICJnZXRJbnQzMiIKQHNlbmQgZXh0ZXJuYWwgc2V0STMyQ29yZTogKERhdGFWaWV3LnQsIGludCwgaW50LCBib29sKSA9PiB1bml0ID0gInNldEludDMyIgpAc2VuZCBleHRlcm5hbCBnZXRVMzJDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBib29sKSA9PiBpbnQgPSAiZ2V0VWludDMyIgpAc2VuZCBleHRlcm5hbCBzZXRVMzJDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBpbnQsIGJvb2wpID0+IHVuaXQgPSAic2V0VWludDMyIgpAc2VuZCBleHRlcm5hbCBnZXRJNjRDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBib29sKSA9PiBiaWdpbnQgPSAiZ2V0QmlnSW50NjQiCkBzZW5kIGV4dGVybmFsIHNldEk2NENvcmU6IChEYXRhVmlldy50LCBpbnQsIGJpZ2ludCwgYm9vbCkgPT4gdW5pdCA9CiAgInNldEJpZ0ludDY0IgpAc2VuZCBleHRlcm5hbCBnZXRVNjRDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBib29sKSA9PiBiaWdpbnQgPSAiZ2V0QmlnVWludDY0IgpAc2VuZCBleHRlcm5hbCBzZXRVNjRDb3JlOiAoRGF0YVZpZXcudCwgaW50LCBiaWdpbnQsIGJvb2wpID0+IHVuaXQgPQogICJzZXRCaWdVaW50NjQiCkBzZW5kIGV4dGVybmFsIGdldEYzMkNvcmU6IChEYXRhVmlldy50LCBpbnQsIGJvb2wpID0+IGZsb2F0ID0gImdldEZsb2F0MzIiCkBzZW5kIGV4dGVybmFsIHNldEYzMkNvcmU6IChEYXRhVmlldy50LCBpbnQsIGZsb2F0LCBib29sKSA9PiB1bml0ID0gInNldEZsb2F0MzIiCkBzZW5kIGV4dGVybmFsIGdldEY2NENvcmU6IChEYXRhVmlldy50LCBpbnQsIGJvb2wpID0+IGZsb2F0ID0gImdldEZsb2F0NjQiCkBzZW5kIGV4dGVybmFsIHNldEY2NENvcmU6IChEYXRhVmlldy50LCBpbnQsIGZsb2F0LCBib29sKSA9PiB1bml0ID0gInNldEZsb2F0NjQiCgpsZXQgY29uc0ZsYWc6IGludCA9IDB4ODBfMDBfMDBfMDAKbGV0IG5vdENvbnNGbGFnOiBpbnQgPSAweDdmX2ZmX2ZmX2ZmCmxldCBoZWFkZXJTaXplOiBpbnQgPSA0CgpsZXQgYXJyYXlUb0hlYWREYXRhVmlldzogVWludDhBcnJheS50ID0+IG9wdGlvbjxEYXRhVmlldy50PiA9IChhcnkpID0+IHsKICBsZXQgbGVuID0gYXJ5LT5UeXBlZEFycmF5LmJ5dGVMZW5ndGgKCiAgaWYgbGVuID49IDQgewogICAgU29tZShEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICBhcnktPlR5cGVkQXJyYXkuYnVmZmVyLAogICAgICB+Ynl0ZU9mZnNldCA9IGFyeS0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICB+bGVuZ3RoID0gaGVhZGVyU2l6ZQogICAgKSkKICB9IGVsc2UgewogICAgTm9uZQogIH0KfQoKbGV0IGRhdGFWaWV3VG9TZXhwckhlYWRlcjogRGF0YVZpZXcudCA9PiBzZXhwckhlYWRlciA9ICh2aWV3KSA9PiB7CiAgbGV0IHNpemUgPSB2aWV3LT5nZXRVMzJDb3JlKDAsIHRydWUpCgogIGlmIHNpemUgPT09IDAgewogICAgTmlsCiAgfSBlbHNlIGlmIGxhbmQoc2l6ZSwgbm90Q29uc0ZsYWcpID09PSBzaXplIHsKICAgIEF0b20oc2l6ZSkKICB9IGVsc2UgewogICAgQ29ucyhsYW5kKHNpemUsIG5vdENvbnNGbGFnKSkKICB9Cn0KCmxldCBzZXRTZXhwckhlYWRlclRvRGF0YVZpZXc6IChEYXRhVmlldy50LCBzZXhwckhlYWRlcikgPT4gdW5pdCA9CiAgKHZpZXcsIGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICB8IE5pbCA9PiB2aWV3LT5zZXRVMzJDb3JlKDAsIDAsIHRydWUpCiAgICB8IEF0b20oc2l6ZSkgPT4gdmlldy0+c2V0VTMyQ29yZSgwLCBsYW5kKHNpemUsIG5vdENvbnNGbGFnKSwgdHJ1ZSkKICAgIHwgQ29ucyhzaXplKSA9PgogICAgICB2aWV3LT5zZXRVMzJDb3JlKDAsIGxvcihsYW5kKHNpemUsIG5vdENvbnNGbGFnKSwgY29uc0ZsYWcpLCB0cnVlKQogIH0KCmxldCBnZXRIZWFkZXI6IGNob2JpdFNleHByID0+IG9wdGlvbjxzZXhwckhlYWRlcj4gPQogIChzZXhwcikgPT4gc2V4cHItPmFycmF5VG9IZWFkRGF0YVZpZXctPk9wdGlvbi5tYXAoCiAgICAodmlldykgPT4gdmlldy0+ZGF0YVZpZXdUb1NleHBySGVhZGVyCiAgKQoKbGV0IGlzTmlsOiBjaG9iaXRTZXhwciA9PiBib29sID0KICAoc2V4cHIpID0+IHN3aXRjaCBzZXhwci0+Z2V0SGVhZGVyIHsKICAgIHwgTm9uZSA9PiBmYWxzZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgTmlsID0+IHRydWUKICAgICAgfCBfID0+IGZhbHNlCiAgICB9CiAgfQoKbGV0IGlzQXRvbTogY2hvYml0U2V4cHIgPT4gYm9vbCA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gZmFsc2UKICAgIHwgU29tZShoZWFkZXIpID0+IHN3aXRjaCBoZWFkZXIgewogICAgICB8IEF0b20oXykgPT4gdHJ1ZQogICAgICB8IF8gPT4gZmFsc2UKICAgIH0KICB9CgpsZXQgaXNDb25zOiBjaG9iaXRTZXhwciA9PiBib29sID0KICAoc2V4cHIpID0+IHN3aXRjaCBzZXhwci0+Z2V0SGVhZGVyIHsKICAgIHwgTm9uZSA9PiBmYWxzZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQ29ucyhfKSA9PiB0cnVlCiAgICAgIHwgXyA9PiBmYWxzZQogICAgfQogIH0KCmxldCBnZXRBdG9tTGVuZ3RoOiBjaG9iaXRTZXhwciA9PiBvcHRpb248aW50PiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQXRvbShsZW4pID0+IFNvbWUobGVuKQogICAgICB8IF8gPT4gTm9uZQogICAgfQogIH0KCmxldCBnZXRBdG9tOiBjaG9iaXRTZXhwciA9PiBvcHRpb248VWludDhBcnJheS50PiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQXRvbShzaXplKSA9PiB7CiAgICAgICAgbGV0IGVuZCA9IGhlYWRlclNpemUgKyBzaXplCiAgICAgICAgaWYgc2V4cHItPlR5cGVkQXJyYXkubGVuZ3RoIDw9IGVuZCB7CiAgICAgICAgICAgIFNvbWUoc2V4cHItPlR5cGVkQXJyYXkuc3ViYXJyYXkoCiAgICAgICAgICAgICAgfnN0YXJ0ID0gaGVhZGVyU2l6ZSwKICAgICAgICAgICAgICB+ZW5kID0gZW5kCiAgICAgICAgICAgICkpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIE5vbmUKICAgICAgICB9CiAgICAgIH0KICAgICAgfCBfID0+IE5vbmUKICAgIH0KICB9CgpsZXQgZ2V0RGF0YVZpZXc6IGNob2JpdFNleHByID0+IG9wdGlvbjxzZXhwckRhdGFWaWV3PiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQXRvbShzaXplKSA9PiB7CiAgICAgICAgaWYgc2V4cHItPlR5cGVkQXJyYXkubGVuZ3RoIDw9IChoZWFkZXJTaXplICsgc2l6ZSkgewogICAgICAgICAgbGV0IG9mZnNldCA9IHNleHByLT5UeXBlZEFycmF5LmJ5dGVPZmZzZXQgKyBoZWFkZXJTaXplCgogICAgICAgICAgU29tZShEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgICAgICBzZXhwci0+VHlwZWRBcnJheS5idWZmZXIsCiAgICAgICAgICAgIH5ieXRlT2Zmc2V0ID0gb2Zmc2V0LAogICAgICAgICAgICB+bGVuZ3RoID0gc2l6ZQogICAgICAgICAgKSkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgTm9uZQogICAgICAgIH0KICAgICAgfQogICAgICB8IF8gPT4gTm9uZQogICAgfQogIH0KCmxldCBieXRlU2l6ZTogc2V4cHJEYXRhVmlldyA9PiBpbnQgPSAodmlldykgPT4gdmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aAoKbGV0IGdldENhcjogY2hvYml0U2V4cHIgPT4gb3B0aW9uPGNob2JpdFNleHByPiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQ29ucyhzaXplKSA9PiBTb21lKHNleHByLT5UeXBlZEFycmF5LnN1YmFycmF5KAogICAgICAgIH5zdGFydCA9IGhlYWRlclNpemUsCiAgICAgICAgfmVuZCA9IGhlYWRlclNpemUgKyBzaXplCiAgICAgICkpCiAgICAgIHwgXyA9PiBOb25lCiAgICB9CiAgfQoKbGV0IGdldENkcjogY2hvYml0U2V4cHIgPT4gb3B0aW9uPGNob2JpdFNleHByPiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQ29ucyhzaXplKSA9PiBTb21lKHNleHByLT5UeXBlZEFycmF5LnN1YmFycmF5VG9FbmQoCiAgICAgICAgfnN0YXJ0ID0gaGVhZGVyU2l6ZSArIHNpemUsCiAgICAgICkpCiAgICAgIHwgXyA9PiBOb25lCiAgICB9CiAgfQoKbGV0IGdldENhckNkcjogY2hvYml0U2V4cHIgPT4gb3B0aW9uPChjaG9iaXRTZXhwciwgY2hvYml0U2V4cHIpPiA9CiAgKHNleHByKSA9PiBzd2l0Y2ggc2V4cHItPmdldEhlYWRlciB7CiAgICB8IE5vbmUgPT4gTm9uZQogICAgfCBTb21lKGhlYWRlcikgPT4gc3dpdGNoIGhlYWRlciB7CiAgICAgIHwgQ29ucyhzaXplKSA9PiB7CiAgICAgICAgbGV0IGNkck9mZnNldCA9IGhlYWRlclNpemUgKyBzaXplCgogICAgICAgIFNvbWUoKAogICAgICAgICAgc2V4cHItPlR5cGVkQXJyYXkuc3ViYXJyYXkoCiAgICAgICAgICAgIH5zdGFydCA9IGhlYWRlclNpemUsCiAgICAgICAgICAgIH5lbmQgPSBjZHJPZmZzZXQKICAgICAgICAgICksCiAgICAgICAgICBzZXhwci0+VHlwZWRBcnJheS5zdWJhcnJheVRvRW5kKAogICAgICAgICAgICB+c3RhcnQgPSBjZHJPZmZzZXQKICAgICAgICAgICkKICAgICAgICApKQogICAgICB9CiAgICAgIHwgXyA9PiBOb25lCiAgICB9CiAgfQoKbGV0IGZvckVhY2g6IChjaG9iaXRTZXhwciwgY2hvYml0U2V4cHIgPT4gdW5pdCkgPT4gY2hvYml0U2V4cHIgPQogIChzZXhwciwgcHJvYykgPT4gewogICAgbGV0IHNleHByID0gcmVmKHNleHByKQogICAgbGV0IGxvb3AgPSByZWYodHJ1ZSkKCiAgICB3aGlsZSBsb29wLmNvbnRlbnRzIHsKICAgICAgc3dpdGNoIHNleHByLmNvbnRlbnRzLT5nZXRDYXJDZHIgewogICAgICAgIHwgTm9uZSA9PiB7bG9vcCA6PSBmYWxzZX0KICAgICAgICB8IFNvbWUoKGNhciwgY2RyKSkgPT4gewogICAgICAgICAgcHJvYyhjYXIpCiAgICAgICAgICBzZXhwciA6PSBjZHIKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBzZXhwci5jb250ZW50cwogIH0KCmxldCBnZXRJODogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248aW50PiA9CiAgKHZpZXcpID0+IGlmICh2aWV3LT5EYXRhVmlldy5ieXRlTGVuZ3RoKSA9PSAxIHsKICAgIFNvbWUodmlldy0+Z2V0SThDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0STg6IChzZXhwckRhdGFWaWV3LCBpbnQpID0+IGJvb2wgPQogICh2aWV3LCB2YWwpID0+IGlmICh2aWV3LT5EYXRhVmlldy5ieXRlTGVuZ3RoKSA9PSAxIHsKICAgIHZpZXctPnNldEk4Q29yZSgwLCB2YWwsIHRydWUpCiAgICB0cnVlCiAgfSBlbHNlIHsKICAgIGZhbHNlCiAgfQoKbGV0IGdldFU4OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDEgewogICAgU29tZSh2aWV3LT5nZXRVOENvcmUoMCwgdHJ1ZSkpCiAgfSBlbHNlIHsKICAgIE5vbmUKICB9CmxldCBzZXRVODogKHNleHByRGF0YVZpZXcsIGludCkgPT4gYm9vbCA9CiAgKHZpZXcsIHZhbCkgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDEgewogICAgdmlldy0+c2V0VThDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0STE2OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDIgewogICAgU29tZSh2aWV3LT5nZXRJMTZDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0STE2OiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gMiB7CiAgICB2aWV3LT5zZXRJMTZDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0VTE2OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDIgewogICAgU29tZSh2aWV3LT5nZXRVMTZDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0VTE2OiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gMiB7CiAgICB2aWV3LT5zZXRVMTZDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0STMyOiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDQgewogICAgU29tZSh2aWV3LT5nZXRJMzJDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0STMyOiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gNCB7CiAgICB2aWV3LT5zZXRJMzJDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0VTMyOiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDQgewogICAgU29tZSh2aWV3LT5nZXRVMzJDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0VTMyOiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gNCB7CiAgICB2aWV3LT5zZXRVMzJDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0STY0OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxiaWdpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDggewogICAgU29tZSh2aWV3LT5nZXRJNjRDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0STY0OiAoc2V4cHJEYXRhVmlldywgYmlnaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gOCB7CiAgICB2aWV3LT5zZXRJNjRDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0VTY0OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxiaWdpbnQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDggewogICAgU29tZSh2aWV3LT5nZXRVNjRDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0VTY0OiAoc2V4cHJEYXRhVmlldywgYmlnaW50KSA9PiBib29sID0KICAodmlldywgdmFsKSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gOCB7CiAgICB2aWV3LT5zZXRVNjRDb3JlKDAsIHZhbCwgdHJ1ZSkKICAgIHRydWUKICB9IGVsc2UgewogICAgZmFsc2UKICB9CgpsZXQgZ2V0RjMyOiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxmbG9hdD4gPQogICh2aWV3KSA9PiBpZiAodmlldy0+RGF0YVZpZXcuYnl0ZUxlbmd0aCkgPT0gNCB7CiAgICBTb21lKHZpZXctPmdldEYzMkNvcmUoMCwgdHJ1ZSkpCiAgfSBlbHNlIHsKICAgIE5vbmUKICB9CmxldCBzZXRGMzI6IChzZXhwckRhdGFWaWV3LCBmbG9hdCkgPT4gYm9vbCA9CiAgKHZpZXcsIHZhbCkgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDQgewogICAgdmlldy0+c2V0RjMyQ29yZSgwLCB2YWwsIHRydWUpCiAgICB0cnVlCiAgfSBlbHNlIHsKICAgIGZhbHNlCiAgfQoKbGV0IGdldEY2NDogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248ZmxvYXQ+ID0KICAodmlldykgPT4gaWYgKHZpZXctPkRhdGFWaWV3LmJ5dGVMZW5ndGgpID09IDggewogICAgU29tZSh2aWV3LT5nZXRGNjRDb3JlKDAsIHRydWUpKQogIH0gZWxzZSB7CiAgICBOb25lCiAgfQpsZXQgc2V0RjY0OiAoc2V4cHJEYXRhVmlldywgZmxvYXQpID0+IGJvb2wgPQogICh2aWV3LCB2YWwpID0+IGlmICh2aWV3LT5EYXRhVmlldy5ieXRlTGVuZ3RoKSA9PSA4IHsKICAgIHZpZXctPnNldEY2NENvcmUoMCwgdmFsLCB0cnVlKQogICAgdHJ1ZQogIH0gZWxzZSB7CiAgICBmYWxzZQogIH0KCmxldCBjcmVhdGVDaG9iaXRTZXhwckJ1ZjogdW5pdCA9PiBjaG9iaXRTZXhwckJ1ZiA9ICgpID0+IEVtcHR5CgpsZXQgaXNFbXB0eTogY2hvYml0U2V4cHJCdWYgPT4gYm9vbCA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IEVtcHR5ID0+IHRydWUKICAgIHwgXyA9PiBmYWxzZQogIH0KCmxldCBpc0NvbXBsZXRlZDogY2hvYml0U2V4cHJCdWYgPT4gYm9vbCA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENvbXBsZXRlZChfKSA9PiB0cnVlCiAgICB8IF8gPT4gZmFsc2UKICB9CgpsZXQgaXNCdWlsZGluZ0NhcjogY2hvYml0U2V4cHJCdWYgPT4gYm9vbCA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENhciA9PiB0cnVlCiAgICB8IF8gPT4gZmFsc2UKICB9CgpsZXQgaXNCdWlsZGluZ0NkcjogY2hvYml0U2V4cHJCdWYgPT4gYm9vbCA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENkcihfKSA9PiB0cnVlCiAgICB8IF8gPT4gZmFsc2UKICB9CgpsZXQgaXNCdWlsZGluZ0xpc3Q6IGNob2JpdFNleHByQnVmID0+IGJvb2wgPQogIChidWYpID0+IHN3aXRjaCBidWYgewogICAgfCBMaXN0KF8pID0+IHRydWUKICAgIHwgXyA9PiBmYWxzZQogIH0KCmxldCBnZXRTZXhwcjogY2hvYml0U2V4cHJCdWYgPT4gb3B0aW9uPGNob2JpdFNleHByPiA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENvbXBsZXRlZChzZXhwcikgPT4gU29tZShzZXhwcikKICAgIHwgXyA9PiBOb25lCiAgfQoKbGV0IHB1c2hTZXhwcjogKGNob2JpdFNleHByQnVmLCBjaG9iaXRTZXhwcikgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYsIHNleHByKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgRW1wdHkgPT4gQ29tcGxldGVkKHNleHByKQogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoTmlsOiBjaG9iaXRTZXhwckJ1ZiA9PiBjaG9iaXRTZXhwckJ1ZiA9CiAgKGJ1ZikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IEVtcHR5ID0+IHsKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UoaGVhZGVyU2l6ZSkKICAgICAgbGV0IHJldCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcihyZXRCdWYpCgogICAgICBsZXQgdmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXIocmV0QnVmKQoKICAgICAgdmlldy0+c2V0U2V4cHJIZWFkZXJUb0RhdGFWaWV3KE5pbCkKCiAgICAgIENvbXBsZXRlZChyZXQpCiAgICB9CgogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoQXRvbTogKGNob2JpdFNleHByQnVmLCBVaW50OEFycmF5LnQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBhcnkpID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSBhcnktPlR5cGVkQXJyYXkubGVuZ3RoCgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShoZWFkZXJTaXplICsgbGVuKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKCiAgICAgIGxldCB2aWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSAwLAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIHZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHJldC0+b3ZlcndyaXRlKGFyeSwgaGVhZGVyU2l6ZSkKCiAgICAgIENvbXBsZXRlZChyZXQpCiAgICB9CgogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBidWlsZENvbnM6IGNob2JpdFNleHByQnVmID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgRW1wdHkgPT4gQ2FyCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hDYXI6IChjaG9iaXRTZXhwckJ1ZiwgY2hvYml0U2V4cHIpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBzZXhwcikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENhciA9PiBDZHIoc2V4cHIpCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hDZHI6IChjaG9iaXRTZXhwckJ1ZiwgY2hvYml0U2V4cHIpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBzZXhwcikgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IENkcihjYXIpID0+IHsKICAgICAgbGV0IGNhckxlbiA9IGNhci0+VHlwZWRBcnJheS5sZW5ndGgKICAgICAgbGV0IGNkckxlbiA9IHNleHByLT5UeXBlZEFycmF5Lmxlbmd0aAoKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UoaGVhZGVyU2l6ZSArIGNhckxlbiArIGNkckxlbikKICAgICAgbGV0IHJldCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcihyZXRCdWYpCgogICAgICBsZXQgaGVhZGVyT2Zmc2V0ID0gMAogICAgICBsZXQgY2FyT2Zmc2V0ID0gaGVhZGVyT2Zmc2V0ICsgaGVhZGVyU2l6ZQogICAgICBsZXQgY2RyT2Zmc2V0ID0gY2FyT2Zmc2V0ICsgY2FyTGVuCiAgICAgIGxldCBjZHJFbmQgPSBjZHJPZmZzZXQgKyBjZHJMZW4KCiAgICAgIGxldCBoZWFkZXJQYXJ0ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJPZmZzZXQsCiAgICAgICAgfmxlbmd0aCA9IGhlYWRlclNpemUKICAgICAgKQoKICAgICAgbGV0IGNhclBhcnQgPSByZXQtPlR5cGVkQXJyYXkuc3ViYXJyYXkoCiAgICAgICAgfnN0YXJ0ID0gY2FyT2Zmc2V0LAogICAgICAgIH5lbmQgPSBjZHJPZmZzZXQKICAgICAgKQoKICAgICAgbGV0IGNkclBhcnQgPSByZXQtPlR5cGVkQXJyYXkuc3ViYXJyYXkoCiAgICAgICAgfnN0YXJ0ID0gY2RyT2Zmc2V0LAogICAgICAgIH5lbmQgPSBjZHJFbmQKICAgICAgKQoKICAgICAgaGVhZGVyUGFydC0+c2V0U2V4cHJIZWFkZXJUb0RhdGFWaWV3KENvbnMoY2FyTGVuKSkKICAgICAgY2FyUGFydC0+b3ZlcndyaXRlKGNhciwgMCkKICAgICAgY2RyUGFydC0+b3ZlcndyaXRlKHNleHByLCAwKQoKICAgICAgQ29tcGxldGVkKHJldCkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IGJ1aWxkTGlzdDogY2hvYml0U2V4cHJCdWYgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYpID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiBMaXN0KFtdKQogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoSXRlbTogKGNob2JpdFNleHByQnVmLCBjaG9iaXRTZXhwcikgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYsIHNleHByKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgTGlzdChzZXhwckFyeSkgPT4gewogICAgICBzZXhwckFyeS0+QXJyYXkucHVzaChzZXhwcikKICAgICAgTGlzdChzZXhwckFyeSkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IGZpbmlzaExpc3Q6IChjaG9iaXRTZXhwckJ1Ziwgfmxhc3RTZXhwcjogY2hvYml0U2V4cHI9PykgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYsIH5sYXN0U2V4cHI6IG9wdGlvbjxjaG9iaXRTZXhwcj49PykgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IExpc3Qoc2V4cHJBcnkpID0+IHsKICAgICAgbGV0IGxlbiA9IHJlZigwKQoKICAgICAgc2V4cHJBcnktPkFycmF5LmZvckVhY2goCiAgICAgICAgKHNleHByKSA9PiB7CiAgICAgICAgICBsZW4gOj0gbGVuLmNvbnRlbnRzICsgaGVhZGVyU2l6ZSArIHNleHByLT5UeXBlZEFycmF5Lmxlbmd0aAogICAgICAgIH0KICAgICAgKQoKICAgICAgbGV0IGxlbiA9IGxlbi5jb250ZW50cyArIHN3aXRjaCBsYXN0U2V4cHIgewogICAgICAgIHwgU29tZShzZXhwcikgPT4gc2V4cHItPlR5cGVkQXJyYXkubGVuZ3RoCiAgICAgICAgfCBOb25lID0+IGhlYWRlclNpemUKICAgICAgfQoKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UobGVuKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBvZmZzZXQgPSByZWYocmV0LT5UeXBlZEFycmF5LmJ5dGVPZmZzZXQpCgogICAgICBzZXhwckFyeS0+QXJyYXkuZm9yRWFjaCgKICAgICAgICAoc2V4cHIpID0+IHsKICAgICAgICAgIGxldCBzZXhwckxlbiA9IHNleHByLT5UeXBlZEFycmF5Lmxlbmd0aAoKICAgICAgICAgIGxldCBoZWFkZXJQYXJ0ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICAgICAgcmV0QnVmLAogICAgICAgICAgICB+Ynl0ZU9mZnNldCA9IG9mZnNldC5jb250ZW50cywKICAgICAgICAgICAgfmxlbmd0aCA9IGhlYWRlclNpemUKICAgICAgICAgICkKCiAgICAgICAgICBsZXQgY2FyUGFydCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICAgICAgcmV0QnVmLAogICAgICAgICAgICB+Ynl0ZU9mZnNldCA9IG9mZnNldC5jb250ZW50cyArIGhlYWRlclNpemUsCiAgICAgICAgICAgIH5sZW5ndGggPSBzZXhwckxlbgogICAgICAgICAgKQoKICAgICAgICAgIGhlYWRlclBhcnQtPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhDb25zKHNleHByTGVuKSkKICAgICAgICAgIGNhclBhcnQtPm92ZXJ3cml0ZShzZXhwciwgMCkKCiAgICAgICAgICBvZmZzZXQgOj0gb2Zmc2V0LmNvbnRlbnRzICsgaGVhZGVyU2l6ZSArIHNleHByTGVuCiAgICAgICAgfQogICAgICApCgogICAgICBzd2l0Y2ggbGFzdFNleHByIHsKICAgICAgICB8IFNvbWUobGFzdCkgPT4gewogICAgICAgICAgbGV0IGxhc3RMZW4gPSBsYXN0LT5UeXBlZEFycmF5Lmxlbmd0aAoKICAgICAgICAgIGxldCBjZHJQYXJ0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgICAgICByZXRCdWYsCiAgICAgICAgICAgIH5ieXRlT2Zmc2V0ID0gb2Zmc2V0LmNvbnRlbnRzLAogICAgICAgICAgICB+bGVuZ3RoID0gbGFzdExlbgogICAgICAgICAgKQoKICAgICAgICAgIGNkclBhcnQtPm92ZXJ3cml0ZShsYXN0LCAwKQoKICAgICAgICAgIENvbXBsZXRlZChyZXQpCiAgICAgICAgfQoKICAgICAgICB8IE5vbmUgPT4gewogICAgICAgICAgbGV0IGhlYWRlclBhcnQgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgICAgICByZXRCdWYsCiAgICAgICAgICAgIH5ieXRlT2Zmc2V0ID0gb2Zmc2V0LmNvbnRlbnRzLAogICAgICAgICAgICB+bGVuZ3RoID0gaGVhZGVyU2l6ZQogICAgICAgICAgKQoKICAgICAgICAgIGhlYWRlclBhcnQtPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhOaWwpCgogICAgICAgICAgQ29tcGxldGVkKHJldCkKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hJODogKGNob2JpdFNleHByQnVmLCBpbnQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBudW0pID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSAxCgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShsZW4gKyBoZWFkZXJTaXplKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKICAgICAgbGV0IGhlYWRlclZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IHJldC0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGxldCBwYXlsb2FkVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJUb0VuZCgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGhlYWRlclZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHBheWxvYWRWaWV3LT5zZXRJOENvcmUoMCwgbnVtLCB0cnVlKQoKICAgICAgQ29tcGxldGVkKHJldCkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hVODogKGNob2JpdFNleHByQnVmLCBpbnQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBudW0pID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSAxCgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShsZW4gKyBoZWFkZXJTaXplKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKICAgICAgbGV0IGhlYWRlclZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IHJldC0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGxldCBwYXlsb2FkVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJUb0VuZCgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGhlYWRlclZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHBheWxvYWRWaWV3LT5zZXRVOENvcmUoMCwgbnVtLCB0cnVlKQoKICAgICAgQ29tcGxldGVkKHJldCkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hJMTY6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZiA9CiAgKGJ1ZiwgbnVtKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgRW1wdHkgPT4gewogICAgICBsZXQgbGVuID0gMgoKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UobGVuICsgaGVhZGVyU2l6ZSkKICAgICAgbGV0IHJldCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcihyZXRCdWYpCgogICAgICBsZXQgaGVhZGVyID0gQXRvbShsZW4pCiAgICAgIGxldCBoZWFkZXJWaWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSByZXQtPlR5cGVkQXJyYXkuYnl0ZU9mZnNldCwKICAgICAgICB+bGVuZ3RoID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBsZXQgcGF5bG9hZFZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyVG9FbmQoCiAgICAgICAgcmV0QnVmLAogICAgICAgIH5ieXRlT2Zmc2V0ID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBoZWFkZXJWaWV3LT5zZXRTZXhwckhlYWRlclRvRGF0YVZpZXcoaGVhZGVyKQogICAgICBwYXlsb2FkVmlldy0+c2V0STE2Q29yZSgwLCBudW0sIHRydWUpCgogICAgICBDb21wbGV0ZWQocmV0KQogICAgfQoKICAgIHwgXyA9PiBidWYKICB9CgpsZXQgcHVzaFUxNjogKGNob2JpdFNleHByQnVmLCBpbnQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBudW0pID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSAyCgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShsZW4gKyBoZWFkZXJTaXplKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKICAgICAgbGV0IGhlYWRlclZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IHJldC0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGxldCBwYXlsb2FkVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJUb0VuZCgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGhlYWRlclZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHBheWxvYWRWaWV3LT5zZXRVMTZDb3JlKDAsIG51bSwgdHJ1ZSkKCiAgICAgIENvbXBsZXRlZChyZXQpCiAgICB9CgogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoSTMyOiAoY2hvYml0U2V4cHJCdWYsIGludCkgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYsIG51bSkgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IEVtcHR5ID0+IHsKICAgICAgbGV0IGxlbiA9IDQKCiAgICAgIGxldCByZXRCdWYgPSBBcnJheUJ1ZmZlci5tYWtlKGxlbiArIGhlYWRlclNpemUpCiAgICAgIGxldCByZXQgPSBVaW50OEFycmF5LmZyb21CdWZmZXIocmV0QnVmKQoKICAgICAgbGV0IGhlYWRlciA9IEF0b20obGVuKQogICAgICBsZXQgaGVhZGVyVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJXaXRoUmFuZ2UoCiAgICAgICAgcmV0QnVmLAogICAgICAgIH5ieXRlT2Zmc2V0ID0gcmV0LT5UeXBlZEFycmF5LmJ5dGVPZmZzZXQsCiAgICAgICAgfmxlbmd0aCA9IGhlYWRlclNpemUKICAgICAgKQoKICAgICAgbGV0IHBheWxvYWRWaWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlclRvRW5kKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IGhlYWRlclNpemUKICAgICAgKQoKICAgICAgaGVhZGVyVmlldy0+c2V0U2V4cHJIZWFkZXJUb0RhdGFWaWV3KGhlYWRlcikKICAgICAgcGF5bG9hZFZpZXctPnNldEkzMkNvcmUoMCwgbnVtLCB0cnVlKQoKICAgICAgQ29tcGxldGVkKHJldCkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hVMzI6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZiA9CiAgKGJ1ZiwgbnVtKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgRW1wdHkgPT4gewogICAgICBsZXQgbGVuID0gNAoKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UobGVuICsgaGVhZGVyU2l6ZSkKICAgICAgbGV0IHJldCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcihyZXRCdWYpCgogICAgICBsZXQgaGVhZGVyID0gQXRvbShsZW4pCiAgICAgIGxldCBoZWFkZXJWaWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSByZXQtPlR5cGVkQXJyYXkuYnl0ZU9mZnNldCwKICAgICAgICB+bGVuZ3RoID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBsZXQgcGF5bG9hZFZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyVG9FbmQoCiAgICAgICAgcmV0QnVmLAogICAgICAgIH5ieXRlT2Zmc2V0ID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBoZWFkZXJWaWV3LT5zZXRTZXhwckhlYWRlclRvRGF0YVZpZXcoaGVhZGVyKQogICAgICBwYXlsb2FkVmlldy0+c2V0VTMyQ29yZSgwLCBudW0sIHRydWUpCgogICAgICBDb21wbGV0ZWQocmV0KQogICAgfQoKICAgIHwgXyA9PiBidWYKICB9CgpsZXQgcHVzaEk2NDogKGNob2JpdFNleHByQnVmLCBiaWdpbnQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBudW0pID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSA4CgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShsZW4gKyBoZWFkZXJTaXplKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKICAgICAgbGV0IGhlYWRlclZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IHJldC0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGxldCBwYXlsb2FkVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJUb0VuZCgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGhlYWRlclZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHBheWxvYWRWaWV3LT5zZXRJNjRDb3JlKDAsIG51bSwgdHJ1ZSkKCiAgICAgIENvbXBsZXRlZChyZXQpCiAgICB9CgogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoVTY0OiAoY2hvYml0U2V4cHJCdWYsIGJpZ2ludCkgPT4gY2hvYml0U2V4cHJCdWYgPQogIChidWYsIG51bSkgPT4gc3dpdGNoIGJ1ZiB7CiAgICB8IEVtcHR5ID0+IHsKICAgICAgbGV0IGxlbiA9IDgKCiAgICAgIGxldCByZXRCdWYgPSBBcnJheUJ1ZmZlci5tYWtlKGxlbiArIGhlYWRlclNpemUpCiAgICAgIGxldCByZXQgPSBVaW50OEFycmF5LmZyb21CdWZmZXIocmV0QnVmKQoKICAgICAgbGV0IGhlYWRlciA9IEF0b20obGVuKQogICAgICBsZXQgaGVhZGVyVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJXaXRoUmFuZ2UoCiAgICAgICAgcmV0QnVmLAogICAgICAgIH5ieXRlT2Zmc2V0ID0gcmV0LT5UeXBlZEFycmF5LmJ5dGVPZmZzZXQsCiAgICAgICAgfmxlbmd0aCA9IGhlYWRlclNpemUKICAgICAgKQoKICAgICAgbGV0IHBheWxvYWRWaWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlclRvRW5kKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IGhlYWRlclNpemUKICAgICAgKQoKICAgICAgaGVhZGVyVmlldy0+c2V0U2V4cHJIZWFkZXJUb0RhdGFWaWV3KGhlYWRlcikKICAgICAgcGF5bG9hZFZpZXctPnNldFU2NENvcmUoMCwgbnVtLCB0cnVlKQoKICAgICAgQ29tcGxldGVkKHJldCkKICAgIH0KCiAgICB8IF8gPT4gYnVmCiAgfQoKbGV0IHB1c2hGMzI6IChjaG9iaXRTZXhwckJ1ZiwgZmxvYXQpID0+IGNob2JpdFNleHByQnVmID0KICAoYnVmLCBudW0pID0+IHN3aXRjaCBidWYgewogICAgfCBFbXB0eSA9PiB7CiAgICAgIGxldCBsZW4gPSA0CgogICAgICBsZXQgcmV0QnVmID0gQXJyYXlCdWZmZXIubWFrZShsZW4gKyBoZWFkZXJTaXplKQogICAgICBsZXQgcmV0ID0gVWludDhBcnJheS5mcm9tQnVmZmVyKHJldEJ1ZikKCiAgICAgIGxldCBoZWFkZXIgPSBBdG9tKGxlbikKICAgICAgbGV0IGhlYWRlclZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyV2l0aFJhbmdlKAogICAgICAgIHJldEJ1ZiwKICAgICAgICB+Ynl0ZU9mZnNldCA9IHJldC0+VHlwZWRBcnJheS5ieXRlT2Zmc2V0LAogICAgICAgIH5sZW5ndGggPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGxldCBwYXlsb2FkVmlldyA9IERhdGFWaWV3LmZyb21CdWZmZXJUb0VuZCgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSBoZWFkZXJTaXplCiAgICAgICkKCiAgICAgIGhlYWRlclZpZXctPnNldFNleHBySGVhZGVyVG9EYXRhVmlldyhoZWFkZXIpCiAgICAgIHBheWxvYWRWaWV3LT5zZXRGMzJDb3JlKDAsIG51bSwgdHJ1ZSkKCiAgICAgIENvbXBsZXRlZChyZXQpCiAgICB9CgogICAgfCBfID0+IGJ1ZgogIH0KCmxldCBwdXNoRjY0OiAoY2hvYml0U2V4cHJCdWYsIGZsb2F0KSA9PiBjaG9iaXRTZXhwckJ1ZiA9CiAgKGJ1ZiwgbnVtKSA9PiBzd2l0Y2ggYnVmIHsKICAgIHwgRW1wdHkgPT4gewogICAgICBsZXQgbGVuID0gOAoKICAgICAgbGV0IHJldEJ1ZiA9IEFycmF5QnVmZmVyLm1ha2UobGVuICsgaGVhZGVyU2l6ZSkKICAgICAgbGV0IHJldCA9IFVpbnQ4QXJyYXkuZnJvbUJ1ZmZlcihyZXRCdWYpCgogICAgICBsZXQgaGVhZGVyID0gQXRvbShsZW4pCiAgICAgIGxldCBoZWFkZXJWaWV3ID0gRGF0YVZpZXcuZnJvbUJ1ZmZlcldpdGhSYW5nZSgKICAgICAgICByZXRCdWYsCiAgICAgICAgfmJ5dGVPZmZzZXQgPSByZXQtPlR5cGVkQXJyYXkuYnl0ZU9mZnNldCwKICAgICAgICB+bGVuZ3RoID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBsZXQgcGF5bG9hZFZpZXcgPSBEYXRhVmlldy5mcm9tQnVmZmVyVG9FbmQoCiAgICAgICAgcmV0QnVmLAogICAgICAgIH5ieXRlT2Zmc2V0ID0gaGVhZGVyU2l6ZQogICAgICApCgogICAgICBoZWFkZXJWaWV3LT5zZXRTZXhwckhlYWRlclRvRGF0YVZpZXcoaGVhZGVyKQogICAgICBwYXlsb2FkVmlldy0+c2V0RjY0Q29yZSgwLCBudW0sIHRydWUpCgogICAgICBDb21wbGV0ZWQocmV0KQogICAgfQoKICAgIHwgXyA9PiBidWYKICB9Cg==" download="ChobitSexpr.res">ChobitSexpr.res</a>
//! - <a href="data:text/plain;base64,Ly8gQ29weXJpZ2h0IChDKSAyMDI1IEhpcm9ub3JpIElzaGliYXNoaQovLwovLyBUaGlzIHdvcmsgaXMgZnJlZS4gWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUKLy8gdGVybXMgb2YgdGhlIERvIFdoYXQgVGhlIEZ1Y2sgWW91IFdhbnQgVG8gUHVibGljIExpY2Vuc2UsIFZlcnNpb24gMiwKLy8gYXMgcHVibGlzaGVkIGJ5IFNhbSBIb2NldmFyLiBTZWUgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy4KLy8KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLy8KLy8gICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFCi8vICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDQKLy8KLy8gQ29weXJpZ2h0IChDKSAyMDA0IFNhbSBIb2NldmFyIDxzYW1AaG9jZXZhci5uZXQ+Ci8vCi8vIEV2ZXJ5b25lIGlzIHBlcm1pdHRlZCB0byBjb3B5IGFuZCBkaXN0cmlidXRlIHZlcmJhdGltIG9yIG1vZGlmaWVkCi8vIGNvcGllcyBvZiB0aGlzIGxpY2Vuc2UgZG9jdW1lbnQsIGFuZCBjaGFuZ2luZyBpdCBpcyBhbGxvd2VkIGFzIGxvbmcKLy8gYXMgdGhlIG5hbWUgaXMgY2hhbmdlZC4KLy8KLy8gICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFCi8vICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OCi8vCi8vICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLgoKLy8gQ2hvYml0U2V4cHIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLy8gUy1FeHByZXNzaW9uIGFzIGJ5dGUgc3RyaW5nLgp0eXBlIGNob2JpdFNleHByCgovLyBDcmVhdGVzIENob2JpdFNleHByIGZyb20gVWludDhBcnJheS4KLy8KLy8gLSAxc3QgYXJnOiBTb3VyY2Ugb2JqZWN0LgovLyAtIFJldHVybjogQ2hvYml0U2V4cHIuCmxldCBmcm9tVWludDhBcnJheTogVWludDhBcnJheS50ID0+IGNob2JpdFNleHByCgovLyBDaG9iaXRTZXhwciBhcyBVaW50OEFycmF5LgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByLgovLyAtIFJldHVybjogVWludDhBcnJheS4KbGV0IHRvVWludDhBcnJheTogY2hvYml0U2V4cHIgPT4gVWludDhBcnJheS50CgovLyBDcmVhdGVzIENob2JpdFNleHByIGZyb20gVWludDhBcnJheS4KLy8KLy8gLSAxc3QgYXJnOiBBcnJheUJ1ZmZlci4KLy8gLSAybmQgYXJnOiBzdGFydCBvZiBzZXhwciBpbiBidWZmZXIuCi8vIC0gM3JkIGFyZzogZW5kIG9mIHNleHByIGluIGJ1ZmZlci4KLy8gLSBSZXR1cm46IENob2JpdFNleHByLgpsZXQgZnJvbUJ1ZmZlcjogKEFycmF5QnVmZmVyLnQsIGludCwgaW50KSA9PiBjaG9iaXRTZXhwcgoKLy8gQ2hvYml0U2V4cHIgYXMgVWludDhBcnJheS4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwcgovLyAtIFJldHVybjogKEFycmF5QnVmZmVyLCBzdGFydCBvZiBzZXhwciwgZW5kIG9mIHNleHByKQpsZXQgYnVmZmVyOiBjaG9iaXRTZXhwciA9PiAoQXJyYXlCdWZmZXIudCwgaW50LCBpbnQpCgovLyBTZXhwciBpcyBOaWwgb3Igbm90LgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByLgovLyAtIFJldHVybjogU2V4cHIgaXMgTmlsIG9yIG5vdC4KbGV0IGlzTmlsOiBjaG9iaXRTZXhwciA9PiBib29sCgovLyBTZXhwciBpcyBBdG9tIG9yIG5vdC4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwci4KLy8gLSBSZXR1cm46IFNleHByIGlzIEF0b20gb3Igbm90LgpsZXQgaXNBdG9tOiBjaG9iaXRTZXhwciA9PiBib29sCgovLyBTZXhwciBpcyBDb25zIG9yIG5vdC4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwci4KLy8gLSBSZXR1cm46IFNleHByIGlzIENvbnMgb3Igbm90LgpsZXQgaXNDb25zOiBjaG9iaXRTZXhwciA9PiBib29sCgovLyBJZiBzZXhwciBpcyBhdG9tLCByZXR1cm5zIGxlbmd0aC4gT3RoZXJ3aXNlIE5vbmUuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHIuCi8vIC0gUmV0dXJuOiBMZW5ndGggb2YgYXRvbS4KbGV0IGdldEF0b21MZW5ndGg6IGNob2JpdFNleHByID0+IG9wdGlvbjxpbnQ+CgovLyBJZiBzZXhwciBpcyBhdG9tLCByZXR1cm5zIGF0b20gZGF0YS4gT3RoZXJ3aXNlIE5vbmUuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHIuCi8vIC0gUmV0dXJuOiBBdG9tIGRhdGEuCmxldCBnZXRBdG9tOiBjaG9iaXRTZXhwciA9PiBvcHRpb248VWludDhBcnJheS50PgoKLy8gSWYgc2V4cHIgaXMgY29ucywgcmV0dXJucyBjYXIgc2V4cHIuIE90aGVyd2lzZSBOb25lLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByLgovLyAtIFJldHVybjogQ2FyIHNleHByLgpsZXQgZ2V0Q2FyOiBjaG9iaXRTZXhwciA9PiBvcHRpb248Y2hvYml0U2V4cHI+CgovLyBJZiBzZXhwciBpcyBjb25zLCByZXR1cm5zIGNkciBzZXhwci4gT3RoZXJ3aXNlIE5vbmUuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHIuCi8vIC0gUmV0dXJuOiBDZHIgc2V4cHIuCmxldCBnZXRDZHI6IGNob2JpdFNleHByID0+IG9wdGlvbjxjaG9iaXRTZXhwcj4KCi8vIElmIHNleHByIGlzIGNvbnMsIHJldHVybnMgY2FyIGFuZCBjZHIgc2V4cHIuIE90aGVyd2lzZSBOb25lLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByLgovLyAtIFJldHVybjogKGNhciwgY2RyKS4KbGV0IGdldENhckNkcjogY2hvYml0U2V4cHIgPT4gb3B0aW9uPChjaG9iaXRTZXhwciwgY2hvYml0U2V4cHIpPgoKLy8gSWYgc2V4cHIgaXMgbGlzdCwgZXhlY3V0ZXMgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY3kgY2FyIHNleHByLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByLgovLyAtIDJuZCBhcmc6IENhbGxiYWNrIGZ1bmN0aW9uLgovLyAtIFJldHVybjogTGFzdCBjZHIgc2V4cHIuCmxldCBmb3JFYWNoOiAoY2hvYml0U2V4cHIsIGNob2JpdFNleHByID0+IHVuaXQpID0+IGNob2JpdFNleHByCgovLyBTZXhwckRhdGFWaWV3IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgovLyBBdG9tIGRhdGEgYXMgZGF0YSB2aWV3Lgp0eXBlIHNleHByRGF0YVZpZXcKCi8vIElmIHNleHByIGlzIGF0b20sIHJldHVybnMgYXRvbSBkYXRhIGFzIGRhdGEgdmlldy4gT3RoZXJ3aXNlIE5vbmUuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHIuCi8vIC0gUmV0dXJuOiBEYXRhIHZpZXcuCmxldCBnZXREYXRhVmlldzogY2hvYml0U2V4cHIgPT4gb3B0aW9uPHNleHByRGF0YVZpZXc+CgovLyBHZXRzIHNpemUgb2YgZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIFJldHVybjogQnl0ZSBzaXplIG9mIGRhdGEgdmlldy4KbGV0IGJ5dGVTaXplOiBzZXhwckRhdGFWaWV3ID0+IGludAoKLy8gR2V0cyBpbnQgOCB2YWx1ZSBmcm9tIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSBSZXR1cm46IEludCA4IHZhbHVlLgpsZXQgZ2V0STg6IHNleHByRGF0YVZpZXcgPT4gb3B0aW9uPGludD4gCgovLyBTZXRzIGludCA4IHZhbHVlIHRvIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSAybmQgYXJnOiBJbnQgOCB2YWx1ZS4KLy8gLSBSZXR1cm46IFN1Y2Nlc3Mgb3Igbm90LgpsZXQgc2V0STg6IChzZXhwckRhdGFWaWV3LCBpbnQpID0+IGJvb2wgCgovLyBHZXRzIHVuc2lnbmVkIGludCA4IHZhbHVlIGZyb20gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIFJldHVybjogVW5zaWduZWQgaW50IDggdmFsdWUuCmxldCBnZXRVODogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248aW50PiAKCi8vIFNldHMgdW5zaWduZWQgaW50IDggdmFsdWUgdG8gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIDJuZCBhcmc6IFVuc2lnbmVkIGludCA4IHZhbHVlLgovLyAtIFJldHVybjogU3VjY2VzcyBvciBub3QuCmxldCBzZXRVODogKHNleHByRGF0YVZpZXcsIGludCkgPT4gYm9vbCAKCi8vIEdldHMgaW50IDE2IHZhbHVlIGZyb20gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIFJldHVybjogSW50IDE2IHZhbHVlLgpsZXQgZ2V0STE2OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+IAoKLy8gU2V0cyBpbnQgMTYgdmFsdWUgdG8gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIDJuZCBhcmc6IEludCAxNiB2YWx1ZS4KLy8gLSBSZXR1cm46IFN1Y2Nlc3Mgb3Igbm90LgpsZXQgc2V0STE2OiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sIAoKLy8gR2V0cyB1bnNpZ25lZCBpbnQgMTYgdmFsdWUgZnJvbSBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gUmV0dXJuOiBVbnNpZ25lZCBpbnQgMTYgdmFsdWUuCmxldCBnZXRVMTY6IHNleHByRGF0YVZpZXcgPT4gb3B0aW9uPGludD4gCgovLyBTZXRzIHVuc2lnbmVkIGludCAxNiB2YWx1ZSB0byBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gMm5kIGFyZzogVW5zaWduZWQgaW50IDE2IHZhbHVlLgovLyAtIFJldHVybjogU3VjY2VzcyBvciBub3QuCmxldCBzZXRVMTY6IChzZXhwckRhdGFWaWV3LCBpbnQpID0+IGJvb2wgCgovLyBHZXRzIGludCAzMiB2YWx1ZSBmcm9tIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSBSZXR1cm46IEludCAzMiB2YWx1ZS4KbGV0IGdldEkzMjogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248aW50PiAKCi8vIFNldHMgaW50IDMyIHZhbHVlIHRvIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSAybmQgYXJnOiBJbnQgMzIgdmFsdWUuCi8vIC0gUmV0dXJuOiBTdWNjZXNzIG9yIG5vdC4KbGV0IHNldEkzMjogKHNleHByRGF0YVZpZXcsIGludCkgPT4gYm9vbCAKCi8vIEdldHMgdW5zaWduZWQgaW50IDMyIHZhbHVlIGZyb20gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIFJldHVybjogVW5zaWduZWQgaW50IDMyIHZhbHVlLgpsZXQgZ2V0VTMyOiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxpbnQ+IAoKLy8gU2V0cyB1bnNpZ25lZCBpbnQgMzIgdmFsdWUgdG8gZGF0YSB2aWV3LgovLwovLyAtIDFzdCBhcmc6IFNleHByIGRhdGEgdmlldwovLyAtIDJuZCBhcmc6IFVuc2lnbmVkIGludCAzMiB2YWx1ZS4KLy8gLSBSZXR1cm46IFN1Y2Nlc3Mgb3Igbm90LgpsZXQgc2V0VTMyOiAoc2V4cHJEYXRhVmlldywgaW50KSA9PiBib29sIAoKLy8gR2V0cyBpbnQgNjQgdmFsdWUgZnJvbSBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gUmV0dXJuOiBJbnQgNjQgdmFsdWUuCmxldCBnZXRJNjQ6IHNleHByRGF0YVZpZXcgPT4gb3B0aW9uPGJpZ2ludD4gCgovLyBTZXRzIGludCA2NCB2YWx1ZSB0byBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gMm5kIGFyZzogSW50IDY0IHZhbHVlLgovLyAtIFJldHVybjogU3VjY2VzcyBvciBub3QuCmxldCBzZXRJNjQ6IChzZXhwckRhdGFWaWV3LCBiaWdpbnQpID0+IGJvb2wgCgovLyBHZXRzIHVuc2lnbmVkIGludCA2NCB2YWx1ZSBmcm9tIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSBSZXR1cm46IFVuc2lnbmVkIGludCA2NCB2YWx1ZS4KbGV0IGdldFU2NDogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248YmlnaW50PiAKCi8vIFNldHMgdW5zaWduZWQgaW50IDY0IHZhbHVlIHRvIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSAybmQgYXJnOiBVbnNpZ25lZCBpbnQgNjQgdmFsdWUuCi8vIC0gUmV0dXJuOiBTdWNjZXNzIG9yIG5vdC4KbGV0IHNldFU2NDogKHNleHByRGF0YVZpZXcsIGJpZ2ludCkgPT4gYm9vbCAKCi8vIEdldHMgZmxvYXQgMzIgdmFsdWUgZnJvbSBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gUmV0dXJuOiBGbG9hdCAzMiB2YWx1ZS4KbGV0IGdldEYzMjogc2V4cHJEYXRhVmlldyA9PiBvcHRpb248ZmxvYXQ+IAoKLy8gU2V0cyBmbG9hdCAzMiB2YWx1ZSB0byBkYXRhIHZpZXcuCi8vCi8vIC0gMXN0IGFyZzogU2V4cHIgZGF0YSB2aWV3Ci8vIC0gMm5kIGFyZzogRmxvYXQgMzIgdmFsdWUuCi8vIC0gUmV0dXJuOiBTdWNjZXNzIG9yIG5vdC4KbGV0IHNldEYzMjogKHNleHByRGF0YVZpZXcsIGZsb2F0KSA9PiBib29sIAoKLy8gR2V0cyBmbG9hdCA2NCB2YWx1ZSBmcm9tIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSBSZXR1cm46IEZsb2F0IDY0IHZhbHVlLgpsZXQgZ2V0RjY0OiBzZXhwckRhdGFWaWV3ID0+IG9wdGlvbjxmbG9hdD4gCgovLyBTZXRzIGZsb2F0IDY0IHZhbHVlIHRvIGRhdGEgdmlldy4KLy8KLy8gLSAxc3QgYXJnOiBTZXhwciBkYXRhIHZpZXcKLy8gLSAybmQgYXJnOiBGbG9hdCA2NCB2YWx1ZS4KLy8gLSBSZXR1cm46IFN1Y2Nlc3Mgb3Igbm90LgpsZXQgc2V0RjY0OiAoc2V4cHJEYXRhVmlldywgZmxvYXQpID0+IGJvb2wgCgovLyBDaG9iaXRTZXhwckJ1ZiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgovLyBDaG9iaXRTZXhwciBidWlsZGVyLgovLwovLyBDaG9iaXRTZXhwckJ1ZiBoYXMgNCBtb2Rlcy4KLy8KLy8gLSAnRW1wdHknOiBKdXN0IGFmdGVyIENob2JpdFNleHByQnVmIGhhcyBjcmVhdGVkLgovLyAtICdDbXBwbGV0ZWQnOiBTZXhwciBoYXMgYnVpbHQuCi8vIC0gYEJ1aWxkaW5nQ2FyYDogV2F0aW5nIHRvIHB1c2ggQ2FyIHNleHByLgovLyAtIGBCdWlsZGluZ0NkcmA6IFdhdGluZyB0byBwdXNoIENkciBzZXhwci4KLy8gLSBgQnVpbGRpbnRMaXN0YDogV2FpdGluZyB0byBwdXNoIGxpc3QgaXRlbS4KdHlwZSBjaG9iaXRTZXhwckJ1ZgoKLy8gQ3JlYXRlcyBDaG9iaXRTZXhwckJ1Zi4KLy8KLy8gLSBSZXR1cm46IENob2JpdFNleHByQnVmIG9mICdFbXB0eScgbW9kZS4KbGV0IGNyZWF0ZUNob2JpdFNleHByQnVmOiB1bml0ID0+IGNob2JpdFNleHByQnVmCgovLyBDaG9iaXRTZXhwckJ1ZiBpcyAnRW1wdHknIG1vZGUgb3Igbm90Ci8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSBSZXR1cm46IElzICdFbXB0eScgbW9kZSBvciBub3QuCmxldCBpc0VtcHR5OiBjaG9iaXRTZXhwckJ1ZiA9PiBib29sCgovLyBDaG9iaXRTZXhwckJ1ZiBpcyAnQ29tcGxldGVkJyBtb2RlIG9yIG5vdAovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gUmV0dXJuOiBJcyAnQ29tcGxldGVkJyBtb2RlIG9yIG5vdC4KbGV0IGlzQ29tcGxldGVkOiBjaG9iaXRTZXhwckJ1ZiA9PiBib29sCgovLyBDaG9iaXRTZXhwckJ1ZiBpcyAnQnVpbGRpbmdDYXInIG1vZGUgb3Igbm90Ci8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSBSZXR1cm46IElzICdCdWlsZGluZ0NhcicgbW9kZSBvciBub3QuCmxldCBpc0J1aWxkaW5nQ2FyOiBjaG9iaXRTZXhwckJ1ZiA9PiBib29sCgovLyBDaG9iaXRTZXhwckJ1ZiBpcyAnQnVpbGRpbmdDZHInIG1vZGUgb3Igbm90Ci8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSBSZXR1cm46IElzICdCdWlsZGluZ0NkcicgbW9kZSBvciBub3QuCmxldCBpc0J1aWxkaW5nQ2RyOiBjaG9iaXRTZXhwckJ1ZiA9PiBib29sCgovLyBDaG9iaXRTZXhwckJ1ZiBpcyAnQnVpbGRpbmdMaXN0JyBtb2RlIG9yIG5vdAovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gUmV0dXJuOiBJcyAnQnVpbGRpbmdMaXN0JyBtb2RlIG9yIG5vdC4KbGV0IGlzQnVpbGRpbmdMaXN0OiBjaG9iaXRTZXhwckJ1ZiA9PiBib29sCgovLyBJZiAnQ29tcGxldGVkJyBtb2RlLCByZXR1cm4gc2V4cHIuIE90aGVyd2lzZSBOb25lLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gUmV0dXJuOiBDaG9iaXRTZXhwci4KbGV0IGdldFNleHByOiBjaG9iaXRTZXhwckJ1ZiA9PiBvcHRpb248Y2hvYml0U2V4cHI+CgovLyBJZiAnRW1wdHknIG1vZGUsIHB1c2hlcyBzZXhwciBhbmQgcmV0dXJucyBzZWxmLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gMm5kIGFyZzogU2V4cHIgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hTZXhwcjogKGNob2JpdFNleHByQnVmLCBjaG9iaXRTZXhwcikgPT4gY2hvYml0U2V4cHJCdWYKCi8vIElmICdFbXB0eScgbW9kZSwgcHVzaGVzIG5pbCBhbmQgcmV0dXJucyBzZWxmLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gUmV0dXJuOiBTZWxmLgpsZXQgcHVzaE5pbDogY2hvYml0U2V4cHJCdWYgPT4gY2hvYml0U2V4cHJCdWYKCi8vIElmICdFbXB0eScgbW9kZSwgcHVzaGVzIGRhdGEgYW5kIHJldHVybnMgc2VsZi4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IERhdGEgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hBdG9tOiAoY2hvYml0U2V4cHJCdWYsIFVpbnQ4QXJyYXkudCkgPT4gY2hvYml0U2V4cHJCdWYKCi8vIElmICdFbXB0eScgbW9kZSwgY2hhbmdlcyBtb2RlIGludG8gYnVpbGRpbmcgY29ucy4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIFJldHVybjogU2VsZi4KbGV0IGJ1aWxkQ29uczogY2hvYml0U2V4cHJCdWYgPT4gY2hvYml0U2V4cHJCdWYKCi8vIElmICdCdWlsZGluZ0NhcicgbW9kZSwgcHVzaGVzIHNleHByIGFzIGNhci4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IFNleHByIHRvIHB1c2gKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBwdXNoQ2FyOiAoY2hvYml0U2V4cHJCdWYsIGNob2JpdFNleHByKSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0J1aWxkaW5nQ2RyJyBtb2RlLCBwdXNoZXMgc2V4cHIgYXMgY2RyLgovLwovLyAtIDFzdCBhcmc6IENob2JpdFNleHByQnVmCi8vIC0gMm5kIGFyZzogU2V4cHIgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hDZHI6IChjaG9iaXRTZXhwckJ1ZiwgY2hvYml0U2V4cHIpID0+IGNob2JpdFNleHByQnVmCgovLyBJZiAnRW1wdHknIG1vZGUsIGNoYW5nZXMgbW9kZSBpbnRvIGJ1aWxkaW5nIGNvbnMuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBidWlsZExpc3Q6IGNob2JpdFNleHByQnVmID0+IGNob2JpdFNleHByQnVmCgovLyBJZiAnQnVpbGRpbmdMaXN0JyBtb2RlLCBwdXNoZXMgc2V4cHIuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiBTZXhwciB0byBwdXNoCi8vIC0gUmV0dXJuOiBTZWxmLgpsZXQgcHVzaEl0ZW06IChjaG9iaXRTZXhwckJ1ZiwgY2hvYml0U2V4cHIpID0+IGNob2JpdFNleHByQnVmCgovLyBJZiAnQnVpbGRpbmdMaXN0JyBtb2RlLCBwdXNoZXMgc2V4cHIgYXMgbGFzdCBjZHIuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiBTZXhwciB0byBwdXNoIGFzIGxhc3QgY2RyLiBJZiBOb25lLCB0aGVuIHB1c2hlcyBuaWwuCi8vIC0gUmV0dXJuOiBTZWxmLgpsZXQgZmluaXNoTGlzdDogKGNob2JpdFNleHByQnVmLCB+bGFzdFNleHByOiBjaG9iaXRTZXhwcj0/KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgaW50IDggdmFsdWUgYW5kIHJldHVybnMgc2VsZi4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IGludCA4IHZhbHVlIHRvIHB1c2gKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBwdXNoSTg6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgdW5zaWduZWQgaW50IDggdmFsdWUgYW5kIHJldHVybnMgc2VsZi4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IHVuc2lnbmVkIGludCA4IHZhbHVlIHRvIHB1c2gKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBwdXNoVTg6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgaW50IDE2IHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiBpbnQgMTYgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hJMTY6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgdW5zaWduZWQgaW50IDE2IHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiB1bnNpZ25lZCBpbnQgMTYgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hVMTY6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgaW50IDMyIHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiBpbnQgMzIgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hJMzI6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgdW5zaWduZWQgaW50IDMyIHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiB1bnNpZ25lZCBpbnQgMzIgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hVMzI6IChjaG9iaXRTZXhwckJ1ZiwgaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgaW50IDY0IHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiBpbnQgNjQgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hJNjQ6IChjaG9iaXRTZXhwckJ1ZiwgYmlnaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgdW5zaWduZWQgaW50IDY0IHZhbHVlIGFuZCByZXR1cm5zIHNlbGYuCi8vCi8vIC0gMXN0IGFyZzogQ2hvYml0U2V4cHJCdWYKLy8gLSAybmQgYXJnOiB1bnNpZ25lZCBpbnQgNjQgdmFsdWUgdG8gcHVzaAovLyAtIFJldHVybjogU2VsZi4KbGV0IHB1c2hVNjQ6IChjaG9iaXRTZXhwckJ1ZiwgYmlnaW50KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgZmxvYXQgMzIgdmFsdWUgYW5kIHJldHVybnMgc2VsZi4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IGZsb2F0IDMyIHZhbHVlIHRvIHB1c2gKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBwdXNoRjMyOiAoY2hvYml0U2V4cHJCdWYsIGZsb2F0KSA9PiBjaG9iaXRTZXhwckJ1ZgoKLy8gSWYgJ0VtcHR5JyBtb2RlLCBwdXNoZXMgZmxvYXQgNjQgdmFsdWUgYW5kIHJldHVybnMgc2VsZi4KLy8KLy8gLSAxc3QgYXJnOiBDaG9iaXRTZXhwckJ1ZgovLyAtIDJuZCBhcmc6IGZsb2F0IDY0IHZhbHVlIHRvIHB1c2gKLy8gLSBSZXR1cm46IFNlbGYuCmxldCBwdXNoRjY0OiAoY2hvYml0U2V4cHJCdWYsIGZsb2F0KSA9PiBjaG9iaXRTZXhwckJ1Zgo=" download="ChobitSexpr.resi">ChobitSexpr.resi</a>
//!

use alloc::{
    vec::Vec,
    borrow::{Borrow, ToOwned}
};

use core::{
    mem::size_of,
    slice::{from_raw_parts, from_raw_parts_mut},
    marker::PhantomData,
    ops::{Deref, DerefMut},
    fmt
};

/// Value type for [ChobitSexprError].
#[derive(Debug, Clone, PartialEq)]
pub enum ValueType {
    U8,
    I8,
    U16,
    I16,
    U32,
    I32,
    U64,
    I64,
    U128,
    I128,
    F32,
    F64,
    Str
}

impl ValueType {
    fn as_str(&self) -> &str {
        match self {
            Self::U8 => "U8",
            Self::I8 => "I8",
            Self::U16 => "U16",
            Self::I16 => "I16",
            Self::U32 => "U32",
            Self::I32 => "I32",
            Self::U64 => "U64",
            Self::I64 => "I64",
            Self::U128 => "U64",
            Self::I128 => "I64",
            Self::F32 => "F32",
            Self::F64 => "F64",
            Self::Str => "Str"
        }
    }
}

/// Error for [ChobitSexpr].
#[derive(Debug, Clone, PartialEq)]
pub enum ChobitSexprError {
    /// Error for [SexprHeader].
    HeaderError(SexprHeaderError),

    /// Error in reading value.
    CouldNotRead(ValueType),

    /// Error in writing value.
    CouldNotWrite(ValueType),

    /// It is not [ChobitSexpr].
    NotSexpr,

    /// It is not atom of [ChobitSexpr].
    NotAtom,

    /// It is not cons of [ChobitSexpr].
    NotCons
}

impl fmt::Display for ChobitSexprError {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, r#"{{"error":"ChobitSexprError","kind":"#)?;

        match self {
            Self::HeaderError(error) => {
                <SexprHeaderError as fmt::Display>::fmt(error, formatter)?;
            },

            Self::CouldNotRead(value_type) => {
                write!(
                    formatter,
                    r#""CouldNotRead","value_type":"{}""#,
                    value_type.as_str()
                )?;
            },

            Self::CouldNotWrite(value_type) => {
                write!(
                    formatter,
                    r#""CouldNotWrite","value_type":"{}""#,
                    value_type.as_str()
                )?;
            },

            Self::NotSexpr => {
                write!(formatter, r#""NotSexpr""#)?;
            },

            Self::NotAtom => {
                write!(formatter, r#""NotAtom""#)?;
            },

            Self::NotCons => {
                write!(formatter, r#""NotCons""#)?;
            },
        }

        write!(formatter, "}}")
    }
}

/// Error for [SexprHeader].
#[derive(Debug, Clone, PartialEq)]
pub enum SexprHeaderError {
    /// Couldn't convert from `&[u8]` to [SexprHeader].
    CouldNotConvertFromSlice
}

impl fmt::Display for SexprHeaderError {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, r#"{{"error":"SexprHeaderError","kind":"#)?;

        match self {
            Self::CouldNotConvertFromSlice => {
                write!(formatter, r#""CouldNotConvertFromSlice""#)?;
            }
        }

        write!(formatter, "}}")
    }
}

/// Header size on byte string.
pub const HEADER_SIZE: usize = size_of::<u32>();

/// Mask for flag.
///
/// ```ignore
/// use chobitlibs::chobit_sexpr::*;
///
/// let header = SexprHeader::new_atom(10);
/// assert_eq!(header.to_u32() & FLAG_MASK, ATOM_FLAG);
///
/// let header = SexprHeader::new_cons(10);
/// assert_eq!(header.to_u32() & FLAG_MASK, CONS_FLAG);
/// ```
pub const FLAG_MASK: u32 = 0b10000000_00000000_00000000_00000000;

/// Mask for size.
///
/// ```ignore
/// use chobitlibs::chobit_sexpr::*;
///
/// let header = SexprHeader::new_atom(10);
/// assert_eq!(header.to_u32() & SIZE_MASK, 10);
///
/// let header = SexprHeader::new_cons(10);
/// assert_eq!(header.to_u32() & SIZE_MASK, 10);
/// ```
pub const SIZE_MASK: u32 = !FLAG_MASK;

/// Max size of ChobitSexpr.
pub const SIZE_MAX: usize = SIZE_MASK as usize;

/// Flag of atom.
///
/// See [FLAG_MASK] for details.
pub const ATOM_FLAG: u32 = 0;

/// Flag of cons.
///
/// See [FLAG_MASK] for details.
pub const CONS_FLAG: u32 = FLAG_MASK;

/// Header of ChobitSexpr.
///
/// [SexprHeader] is `u32` value.  
/// This is written on byte string in __little endian__ .
///
/// | Position | Cotents |
/// |-|-|
/// | The hightest of 1 bit | Flag. If sexpr is atom, 0. If sexpr is cons, 1. |
/// | The rest of bits | If the sexpr is atom, a size of payload. If it is cons, a size of car. |
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]
pub struct SexprHeader {
    body: u32
}

impl SexprHeader {
    /// Creates from slice.
    ///
    /// - `slice` : Header as byte string.
    /// - _Return_ : If slice length is 4 bytes or more, returns instance. Otherwise returns error.
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, SexprHeaderError> {
        if slice.len() >= HEADER_SIZE {
            Ok(
                Self {
                    body: u32::from_le(unsafe {*(slice.as_ptr() as *const u32)})
                }
            )
        } else {
            Err(SexprHeaderError::CouldNotConvertFromSlice)
        }
    }

    /// Creates Nil header.
    ///
    /// Nil is 0 size atom.
    ///
    /// - _Return_ : Instance.
    #[inline]
    pub const fn new_nil() -> Self {
        Self {body: 0}
    }

    #[inline]
    const fn new_core(flag: u32, size: usize) -> u32 {
        flag | ((size as u32) & SIZE_MASK)
    }

    /// Creates atom header.
    ///
    /// - `size` : Size of payload.
    /// - _Return_ : Instance.
    #[inline]
    pub const fn new_atom(size: usize) -> Self {
        Self {body: Self::new_core(ATOM_FLAG, size)}
    }

    /// Creates atom header.
    ///
    /// - `car_size` : Size of sexpr on car.
    /// - _Return_ : Instance.
    #[inline]
    pub const fn new_cons(car_size: usize) -> Self {
        Self {body: Self::new_core(CONS_FLAG, car_size)}
    }

    /// Convert into u32.
    ///
    /// - _Return_ : Header as u32.
    #[inline]
    pub const fn to_u32(&self) -> u32 {
        self.body
    }

    /// Convert into bytes.
    ///
    /// - _Return_ : Header as bytes.
    #[inline]
    pub const fn to_bytes(&self) -> [u8; HEADER_SIZE] {
        self.body.to_le_bytes()
    }

    /// Judge if atom or not.
    ///
    /// - _Return_ : If atom, true.
    #[inline]
    pub fn is_atom(&self) -> bool {
        self.body < FLAG_MASK
    }

    /// Judge if cons or not.
    ///
    /// - _Return_ : If cons, true.
    #[inline]
    pub fn is_cons(&self) -> bool {
        self.body >= FLAG_MASK
    }

    /// Gets size.
    ///
    /// - _Return_ : If atom, returns size of payload. If cons, returns size of car.
    #[inline]
    pub fn size(&self) -> usize {
        (self.body & SIZE_MASK) as usize
    }
}

impl Deref for SexprHeader {
    type Target = u32;

    #[inline]
    fn deref(&self) -> &u32 {
        &self.body
    }
}

impl From<u32> for SexprHeader {
    #[inline]
    fn from(src: u32) -> Self {
        Self {body: src}
    }
}

impl From<SexprHeader> for u32 {
    #[inline]
    fn from(header: SexprHeader) -> Self {
        header.body
    }
}

impl From<[u8; HEADER_SIZE]> for SexprHeader {
    #[inline]
    fn from(bytes: [u8; HEADER_SIZE]) -> Self {
        Self {
            body: u32::from_le_bytes(bytes)
        }
    }
}

impl From<SexprHeader> for [u8; HEADER_SIZE] {
    #[inline]
    fn from(header: SexprHeader) -> Self {
        header.to_bytes()
    }
}

/// Structured byte string.
///
/// # Example of atom
///
/// ```ignore
/// extern crate alloc;
/// use alloc::vec::Vec;
///
/// use chobitlibs::chobit_sexpr::{SexprHeader, ChobitSexpr};
///
/// let payload: [u8; 5] = [1, 2, 3, 4, 5];
///
/// let header = SexprHeader::new_atom(payload.len());
///
/// let mut body = Vec::<u8>::new();
///
/// body.extend_from_slice(&header.to_bytes());
/// body.extend_from_slice(&payload);
///
/// let sexpr = ChobitSexpr::new(&body);
///
/// assert_eq!(sexpr.atom().unwrap(), payload.as_slice());
/// ```
///
/// # Example of cons
///
/// ```ignore
/// extern crate alloc;
/// use alloc::vec::Vec;
///
/// use chobitlibs::chobit_sexpr::{SexprHeader, ChobitSexpr};
///
/// let car_payload: [u8; 5] = [1, 2, 3, 4, 5];
///
/// let car_body = {
///
///     let header = SexprHeader::new_atom(car_payload.len());
///
///     let mut body = Vec::<u8>::new();
///
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&car_payload);
///
///     body
/// };
///
/// let car = ChobitSexpr::new(&car_body);
///
/// let cdr_payload: [u8; 5] = [6, 7, 8, 9, 10];
///
/// let cdr_body = {
///     let header = SexprHeader::new_atom(cdr_payload.len());
///
///     let mut body = Vec::<u8>::new();
///
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&cdr_payload);
///
///     body
/// };
///
/// let cdr = ChobitSexpr::new(&cdr_body);
///
/// let mut body = Vec::<u8>::new();
/// let header = SexprHeader::new_cons(car.as_bytes().len());
///
/// body.extend_from_slice(&header.to_bytes());
/// body.extend_from_slice(car.as_bytes());
/// body.extend_from_slice(cdr.as_bytes());
///
/// let sexpr = ChobitSexpr::new(&body);
///
/// assert_eq!(sexpr.car().unwrap().as_bytes(), car.as_bytes());
/// assert_eq!(sexpr.cdr().unwrap().as_bytes(), cdr.as_bytes());
///
/// assert_eq!(sexpr.car().unwrap().atom().unwrap(), car_payload.as_slice());
/// assert_eq!(sexpr.cdr().unwrap().atom().unwrap(), cdr_payload.as_slice());
/// ```
///
/// # Example of TryFrom trait
///
/// ```ignore
/// extern crate alloc;
/// use alloc::vec::Vec;
///
/// use chobitlibs::chobit_sexpr::{SexprHeader, ChobitSexpr};
///
/// {
///     let value: i8 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<i8>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, i8::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: u8 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<u8>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, u8::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: i16 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<i16>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, i16::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: u16 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<u16>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, u16::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: i32 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<i32>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, i32::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: u32 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<u32>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, u32::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: i64 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<i64>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, i64::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: u64 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<u64>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, u64::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: i128 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<i128>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, i128::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: u128 = 111;
///     let header = SexprHeader::new_atom(std::mem::size_of::<u128>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, u128::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: f32 = 111.0;
///     let header = SexprHeader::new_atom(std::mem::size_of::<f32>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_bits().to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, f32::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: f64 = 111.0;
///     let header = SexprHeader::new_atom(std::mem::size_of::<f64>());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.to_bits().to_le_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, f64::try_from(sexpr).unwrap());
/// }
///
/// {
///     let value: &str = "Hello World";
///     let header = SexprHeader::new_atom(value.as_bytes().len());
///
///     let mut body = Vec::<u8>::new();
///     body.extend_from_slice(&header.to_bytes());
///     body.extend_from_slice(&value.as_bytes());
///
///     let sexpr = ChobitSexpr::new(&body);
///
///     assert_eq!(value, <&str>::try_from(sexpr).unwrap());
/// }
/// ```
#[derive(Debug, PartialEq)]
pub struct ChobitSexpr {
    body: [u8]
}

macro_rules! gen_read_doc {
    ($type:ty) => {
        concat!(
            "Reads `",
            stringify!($type), 
r#"` value.

* _Return_ : If the sexpr is atom and the size equals `size_of::<"#,
            stringify!($type), 
r#">()` , returns value. Otherwise, error"#
        )
    };
}

macro_rules! gen_write_doc {
    ($type:ty) => {
        concat!(
            "Writes `",
            stringify!($type), 
r#"` value.

* `value` : Value.
* _Return_ : If the sexpr is atom and the size equals `size_of::<"#,
            stringify!($type), 
r#">()` , returns `Some(())` . Otherwise, error"#
        )
    };
}

macro_rules! value_type {
    (u8) => {ValueType::U8};
    (i8) => {ValueType::I8};
    (u16) => {ValueType::U16};
    (i16) => {ValueType::I16};
    (u32) => {ValueType::U32};
    (i32) => {ValueType::I32};
    (u64) => {ValueType::U64};
    (i64) => {ValueType::I64};
    (u128) => {ValueType::U128};
    (i128) => {ValueType::I128};
}

macro_rules! def_read_write {
    (
        $read_func_name: ident,
        $write_func_name:ident,
        $type:tt
    ) => {
        #[doc = gen_read_doc!($type)]
        #[inline]
        pub fn $read_func_name(&self) -> Result<$type, ChobitSexprError> {
            let atom = self.atom()?;

            if atom.len() == size_of::<$type>() {
                unsafe {
                    Ok(<$type>::from_le(*(atom.as_ptr() as *const $type)))
                }
            } else {
                Err(ChobitSexprError::CouldNotRead(value_type!($type)))
            }
        }

        #[doc = gen_write_doc!($type)]
        #[inline]
        pub fn $write_func_name(
            &mut self,
            value: $type
        ) -> Result<(), ChobitSexprError> {
            let atom = self.atom_mut()?;

            if atom.len() == size_of::<$type>() {
                unsafe {
                    *(atom.as_mut_ptr() as *mut $type) = value.to_le();
                }

                Ok(())
            } else {
                Err(ChobitSexprError::CouldNotWrite(value_type!($type)))
            }
        }
    };
}

impl ChobitSexpr {
    #[inline]
    pub fn nil() -> &'static ChobitSexpr {
        static BYTES: [u8; HEADER_SIZE] =
            SexprHeader::new_nil().to_bytes();

        ChobitSexpr::new(&BYTES)
    }

    /// Creates immutable ChobitSexpr.
    ///
    /// - `value` : Body of the instance.
    /// - _Return_ : Instance.
    #[inline]
    pub fn new<S: AsRef<[u8]> + ?Sized>(value: &S) -> &ChobitSexpr {
        unsafe {&*(value.as_ref() as *const [u8] as *const ChobitSexpr)}
    }

    /// Creates mutable ChobitSexpr.
    ///
    /// - `value` : Body of the instance.
    /// - _Return_ : Instance.
    #[inline]
    pub fn new_mut<S: AsMut<[u8]> + ?Sized>(
        value: &mut S
    ) -> &mut ChobitSexpr {
        unsafe {&mut *(value.as_mut() as *mut [u8] as *mut ChobitSexpr)}
    }

    /// Gets body as slice.
    ///
    /// - _Return_ : Body.
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {&self.body}

    /// Gets header.
    ///
    /// - _Return_ : If it has header, returns it. otherwise returns error.
    #[inline]
    pub fn header(&self) -> Result<SexprHeader, ChobitSexprError> {
        SexprHeader::from_slice(&self.body).map_err(
            |error| ChobitSexprError::HeaderError(error)
        )
    }

    #[inline]
    fn get_atom_size(&self) -> Result<usize, ChobitSexprError> {
        let header = self.header()?;

        if header.is_atom() {
            let size = header.size();

            if size <= (self.body.len() - HEADER_SIZE) {
                Ok(size)
            } else {
                Err(ChobitSexprError::NotSexpr)
            }
        } else {
            Err(ChobitSexprError::NotAtom)
        }
    }

    /// Gets immutable payload of atom.
    ///
    /// - _Return_ : If it is correct atom, returns its payload. otherwise returns error.
    #[inline]
    pub fn atom(&self) -> Result<&[u8], ChobitSexprError> {
        let size = self.get_atom_size()?;

        Ok(unsafe {
            from_raw_parts(self.body.as_ptr().add(HEADER_SIZE), size)
        })
    }

    /// Gets mutable payload of atom.
    ///
    /// - _Return_ : If it is correct atom, returns its payload. otherwise returns error.
    #[inline]
    pub fn atom_mut(&mut self) -> Result<&mut [u8], ChobitSexprError> {
        let size = self.get_atom_size()?;

        Ok(unsafe {
            from_raw_parts_mut(self.body.as_mut_ptr().add(HEADER_SIZE), size)
        })
    }

    #[inline]
    fn cons_size(&self) -> Result<usize, ChobitSexprError> {
        let header = self.header()?;

        if header.is_cons() {
            let size = header.size();

            if size <= (self.body.len() - HEADER_SIZE) {
                Ok(size)
            } else {
                Err(ChobitSexprError::NotSexpr)
            }
        } else {
            Err(ChobitSexprError::NotCons)
        }
    }

    /// Gets immutable car of cons.
    ///
    /// - _Return_ : If it is correct cons, returns its car. otherwise returns error.
    #[inline]
    pub fn car(&self) -> Result<&ChobitSexpr, ChobitSexprError> {
        let size = self.cons_size()?;

        Ok(ChobitSexpr::new(unsafe {
            from_raw_parts(
                self.body.as_ptr().add(HEADER_SIZE),
                size
            )
        }))
    }

    /// Gets mutable car of cons.
    ///
    /// - _Return_ : If it is correct cons, returns its car. otherwise returns error.
    #[inline]
    pub fn car_mut(&mut self) -> Result<&mut ChobitSexpr, ChobitSexprError> {
        let size = self.cons_size()?;

        Ok(ChobitSexpr::new_mut(unsafe {
            from_raw_parts_mut(
                self.body.as_mut_ptr().add(HEADER_SIZE),
                size
            )
        }))
    }

    /// Gets immutable cdr of cons.
    ///
    /// - _Return_ : If it is correct cons, returns its cdr. otherwise returns error.
    #[inline]
    pub fn cdr(&self) -> Result<&ChobitSexpr, ChobitSexprError> {
        let cdr_pos = self.cons_size()? + HEADER_SIZE;

        Ok(ChobitSexpr::new(unsafe {
            from_raw_parts(
                self.body.as_ptr().add(cdr_pos),
                self.body.len() - cdr_pos
            )
        }))
    }

    /// Gets mutable cdr of cons.
    ///
    /// - _Return_ : If it is correct cons, returns its cdr. otherwise returns error.
    #[inline]
    pub fn cdr_mut(&mut self) -> Result<&mut ChobitSexpr, ChobitSexprError> {
        let cdr_pos = self.cons_size()? + HEADER_SIZE;

        Ok(ChobitSexpr::new_mut(unsafe {
            from_raw_parts_mut(
                self.body.as_mut_ptr().add(cdr_pos),
                self.body.len() - cdr_pos
            )
        }))
    }

    /// Gets immutable car and cdr of cons.
    ///
    /// - _Return_ : If it is correct cons, returns its car and cdr. otherwise returns error.
    #[inline]
    pub fn car_cdr(
        &self
    ) -> Result<(&ChobitSexpr, &ChobitSexpr), ChobitSexprError> {
        let car_size = self.cons_size()? + HEADER_SIZE;

        Ok((
            ChobitSexpr::new(unsafe{
                from_raw_parts(
                    self.body.as_ptr().add(HEADER_SIZE),
                    car_size
                )
            }),
            ChobitSexpr::new(unsafe{
                from_raw_parts(
                    self.body.as_ptr().add(car_size),
                    self.body.len() - car_size
                )
            }),
        ))
    }

    def_read_write!(read_i8, write_i8, i8);
    def_read_write!(read_u8, write_u8, u8);
    def_read_write!(read_i16, write_i16, i16);
    def_read_write!(read_u16, write_u16, u16);
    def_read_write!(read_i32, write_i32, i32);
    def_read_write!(read_u32, write_u32, u32);
    def_read_write!(read_i64, write_i64, i64);
    def_read_write!(read_u64, write_u64, u64);
    def_read_write!(read_i128, write_i128, i128);
    def_read_write!(read_u128, write_u128, u128);

    #[doc = gen_read_doc!(f32)]
    #[inline]
    pub fn read_f32(&self) -> Result<f32, ChobitSexprError> {
        let atom = self.atom()?;

        if atom.len() == size_of::<f32>() {
            unsafe {
                Ok(f32::from_bits(
                    u32::from_le(*(atom.as_ptr() as *const u32))
                ))
            }
        } else {
            Err(ChobitSexprError::CouldNotRead(ValueType::F32))
        }
    }

    #[doc = gen_write_doc!(f32)]
    #[inline]
    pub fn write_f32(&mut self, value: f32) -> Result<(), ChobitSexprError> {
        let atom = self.atom_mut()?;

        if atom.len() == size_of::<f32>() {
            unsafe {
                *(atom.as_mut_ptr() as *mut u32) = value.to_bits().to_le();
            }

            Ok(())
        } else {
            Err(ChobitSexprError::CouldNotWrite(ValueType::F32))
        }
    }

    #[doc = gen_read_doc!(f64)]
    #[inline]
    pub fn read_f64(&self) -> Result<f64, ChobitSexprError> {
        let atom = self.atom()?;

        if atom.len() == size_of::<f64>() {
            unsafe {
                Ok(f64::from_bits(
                    u64::from_le(*(atom.as_ptr() as *const u64))
                ))
            }
        } else {
            Err(ChobitSexprError::CouldNotRead(ValueType::F64))
        }
    }

    #[doc = gen_write_doc!(f64)]
    #[inline]
    pub fn write_f64(&mut self, value: f64) -> Result<(), ChobitSexprError> {
        let atom = self.atom_mut()?;

        if atom.len() == size_of::<f64>() {
            unsafe {
                *(atom.as_mut_ptr() as *mut u64) = value.to_bits().to_le();
            }

            Ok(())
        } else {
            Err(ChobitSexprError::CouldNotWrite(ValueType::F64))
        }
    }

    /// Generates an iterator.
    ///
    /// If the sexpr is a list, iterates each car.
    ///
    /// - _Return_ : Iterator.
    ///
    /// ```ignore
    /// use chobitlibs::chobit_sexpr::{ChobitSexpr, ChobitSexprBuf};
    ///
    /// let buf = ChobitSexprBuf::new().build_list().push_item(
    ///     &ChobitSexprBuf::from(100i32)
    /// ).push_item(
    ///     &ChobitSexprBuf::from(200i32)
    /// ).push_item(
    ///     &ChobitSexprBuf::from(300i32)
    /// ).finish();
    ///
    /// let result: Vec<i32> = buf.as_sexpr().iter().map(
    ///     |elm| elm.read_i32().unwrap()
    /// ).collect();
    ///
    /// assert_eq!(result.as_slice(), [100i32, 200i32, 300i32].as_slice());
    /// ```
    #[inline]
    pub fn iter(&self) -> Iter {
        Iter {body: self}
    }
}

pub struct Iter<'a> {
    body: &'a ChobitSexpr
}

impl<'a> Iterator for Iter<'a> {
    type Item = &'a ChobitSexpr;

    #[inline]
    fn next(&mut self) -> Option<&'a ChobitSexpr> {
        let (car, cdr) = self.body.car_cdr().ok()?;
        self.body = cdr;

        Some(car)
    }
}

impl<'a> IntoIterator for &'a ChobitSexpr {
    type Item = Self;
    type IntoIter = Iter<'a>;

    fn into_iter(self) -> Iter<'a> {
        self.iter()
    }
}

impl AsRef<ChobitSexpr> for ChobitSexpr {
    #[inline]
    fn as_ref(&self) -> &ChobitSexpr {
        self
    }
}

impl AsMut<ChobitSexpr> for ChobitSexpr {
    #[inline]
    fn as_mut(&mut self) -> &mut ChobitSexpr {
        self
    }
}

impl AsRef<ChobitSexpr> for [u8] {
    #[inline]
    fn as_ref(&self) -> &ChobitSexpr {
        ChobitSexpr::new(self)
    }
}

impl AsMut<ChobitSexpr> for [u8] {
    #[inline]
    fn as_mut(&mut self) -> &mut ChobitSexpr {
        ChobitSexpr::new_mut(self)
    }
}

impl AsRef<ChobitSexpr> for Vec<u8> {
    #[inline]
    fn as_ref(&self) -> &ChobitSexpr {
        ChobitSexpr::new(self)
    }
}

impl AsMut<ChobitSexpr> for Vec<u8> {
    #[inline]
    fn as_mut(&mut self) -> &mut ChobitSexpr {
        ChobitSexpr::new_mut(self)
    }
}

impl<const N: usize> AsRef<ChobitSexpr> for [u8; N] {
    #[inline]
    fn as_ref(&self) -> &ChobitSexpr {
        ChobitSexpr::new(self)
    }
}

impl<const N: usize> AsMut<ChobitSexpr> for [u8; N] {
    #[inline]
    fn as_mut(&mut self) -> &mut ChobitSexpr {
        ChobitSexpr::new_mut(self)
    }
}

impl ToOwned for ChobitSexpr {
    type Owned = ChobitSexprBuf<Completed>;

    fn to_owned(&self) -> ChobitSexprBuf<Completed> {
        ChobitSexprBuf::<Completed> {
            buffer: self.as_bytes().to_vec(),

            _marker: PhantomData::<Completed>
        }
    }

    fn clone_into(&self, target: &mut ChobitSexprBuf<Completed>) {
        target.buffer = self.as_bytes().to_vec();
    }
}

macro_rules! def_try_from {
    ($type:ty, $read_func_name:ident) => {
        impl TryFrom<&ChobitSexpr> for $type {
            type Error = ChobitSexprError;

            #[inline]
            fn try_from(
                sexpr: &ChobitSexpr
            ) -> Result<$type, ChobitSexprError> {
                sexpr.$read_func_name()
            }
        }
    };
}

def_try_from!(i8, read_i8);
def_try_from!(u8, read_u8);
def_try_from!(i16, read_i16);
def_try_from!(u16, read_u16);
def_try_from!(i32, read_i32);
def_try_from!(u32, read_u32);
def_try_from!(i64, read_i64);
def_try_from!(u64, read_u64);
def_try_from!(i128, read_i128);
def_try_from!(u128, read_u128);

impl TryFrom<&ChobitSexpr> for f32 {
    type Error = ChobitSexprError;

    #[inline]
    fn try_from(sexpr: &ChobitSexpr) -> Result<f32, ChobitSexprError> {
        match u32::try_from(sexpr) {
            Ok(bits) => Ok(f32::from_bits(bits)),

            Err(ChobitSexprError::CouldNotRead(..)) =>
                Err(ChobitSexprError::CouldNotRead(ValueType::F32)),

            Err(error) => Err(error)
        }
    }
}

impl TryFrom<&ChobitSexpr> for f64 {
    type Error = ChobitSexprError;

    #[inline]
    fn try_from(sexpr: &ChobitSexpr) -> Result<f64, ChobitSexprError> {
        match u64::try_from(sexpr) {
            Ok(bits) => Ok(f64::from_bits(bits)),

            Err(ChobitSexprError::CouldNotRead(..)) =>
                Err(ChobitSexprError::CouldNotRead(ValueType::F64)),

            Err(error) => Err(error)
        }
    }
}

impl<'a> TryFrom<&'a ChobitSexpr> for &'a str {
    type Error = ChobitSexprError;

    #[inline]
    fn try_from(sexpr: &'a ChobitSexpr) -> Result<&'a str, ChobitSexprError> {
        core::str::from_utf8(sexpr.atom()?).map_err(
            |_| ChobitSexprError::CouldNotRead(ValueType::Str)
        )
    }
}

impl fmt::Display for ChobitSexpr {
    #[inline]
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        self.fmt_sexpr(0, formatter)
    }
}

impl ChobitSexpr {
    fn write_indent(
        indent: usize,
        formatter: &mut fmt::Formatter
    ) -> fmt::Result {
        for _ in 0..indent {
            write!(formatter, "|    ")?;
        }

        Ok(())
    }

    #[inline]
    fn fmt_sexpr(
        &self,
        indent: usize,
        formatter: &mut fmt::Formatter
    ) -> fmt::Result {
        match self.atom() {
            Ok(atom) => Self::fmt_atom(indent, atom, formatter),

            Err(..) => self.fmt_cons(indent, formatter)
        }
    }

    fn fmt_atom(
        indent: usize,
        atom: &[u8],
        formatter: &mut fmt::Formatter
    ) -> fmt::Result {
        Self::write_indent(indent, formatter)?;

        write!(formatter, "len: {}, bytes: {:02x?}\n", atom.len(), atom)
    }

    fn fmt_cons(
        &self,
        indent: usize,
        formatter: &mut fmt::Formatter
    ) -> fmt::Result {
        let car = self.car().map_err(|_| fmt::Error)?;

        Self::write_indent(indent, formatter)?;
        write!(formatter, "car:\n")?;
        car.fmt_sexpr(indent + 1, formatter)?;

        let cdr = self.cdr().map_err(|_| fmt::Error)?;

        Self::write_indent(indent, formatter)?;
        write!(formatter, "cdr:\n")?;
        cdr.fmt_sexpr(indent + 1, formatter)
    }
}

/// Typestate of ChobitSexprBuf. Indicates empty and imcomplete sexpr.
#[derive(Debug, Clone, PartialEq)]
pub enum Empty {}

/// Typestate of ChobitSexprBuf. Indicates comleted sexpr.
#[derive(Debug, Clone, PartialEq)]
pub enum Completed {}

/// Typestate of ChobitSexprBuf. Indicates to be able to push car.
#[derive(Debug, Clone, PartialEq)]
pub enum Car {}

/// Typestate of ChobitSexprBuf. Indicates to be able to push cdr.
#[derive(Debug, Clone, PartialEq)]
pub enum Cdr {}

/// Typestate of ChobitSexprBuf. Indicates to be able to push list item.
#[derive(Debug, Clone, PartialEq)]
pub enum List {}

mod private {
    use super::{Empty, Completed, Car, Cdr, List};

    pub trait Sealed {}

    impl Sealed for Empty {}
    impl Sealed for Completed {}
    impl Sealed for Car {}
    impl Sealed for Cdr {}
    impl Sealed for List {}
}

/// [ChobitSexpr] in heap memory. It is also [ChobitSexpr] builder.
#[derive(Debug, Clone, PartialEq)]
pub struct ChobitSexprBuf<Mode = Completed>
where
    Mode: private::Sealed
{
    buffer: Vec<u8>,

    _marker: PhantomData<Mode>
}

impl<Mode> ChobitSexprBuf<Mode> where Mode: private::Sealed {
    /// Drops self and clear buffer and take back [Empty] state.
    ///
    /// - _Return_ : ChobitSexpr of Empty state.
    #[inline]
    pub fn clear(self) -> ChobitSexprBuf<Empty> {
        let Self {mut buffer, ..} = self;

        buffer.clear();

        ChobitSexprBuf::<Empty> {
            buffer: buffer,

            _marker: PhantomData::<Empty>
        }
    }
}

macro_rules! push_number {
    ($func_name:ident, $type:ty, $doc:expr) => {
        #[doc = $doc]
        #[inline]
        pub fn $func_name(self, value: $type) -> ChobitSexprBuf<Completed> {
            self.push_atom(&value.to_le_bytes())
        }
    };
}

macro_rules! push_number_doc {
    ($type:ty) => {
        concat!(
r#"Drops and pushes `"#,
stringify!($type),
r#"` value and returns completed sexpr.

* `value` : A value.
* _Return_ : Completed sexpr"#
        )
    };
}

impl ChobitSexprBuf<Empty> {
    /// Creates ChobitSexprBuf. Not allocated on heap memory yet.
    ///
    /// - _Return_ : Instance.
    #[inline]
    pub fn new() -> Self {
        Self {
            buffer: Vec::<u8>::new(),

            _marker: PhantomData::<Empty>
        }
    }

    /// Creates ChobitSexprBuf with memory allocation.
    ///
    /// - `capacity` : allocation size.
    /// - _Return_ : Instance.
    #[inline]
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            buffer: Vec::<u8>::with_capacity(capacity),

            _marker: PhantomData::<Empty>
        }
    }

    /// Drops and returns completed empty sexpr.
    ///
    /// - _Return_ : Completed sexpr.
    #[inline]
    pub fn empty_sexpr(self) -> ChobitSexprBuf<Completed> {
        let Self {buffer, ..} = self;

        ChobitSexprBuf::<Completed> {
            buffer: buffer,
            _marker: PhantomData::<Completed>
        }
    }

    /// Drops and returns instance to be able to push car.
    ///
    /// - _Return_ : ChobitSexprBuf that can push car.
    #[inline]
    pub fn build_cons(self) -> ChobitSexprBuf<Car> {
        let Self {buffer, ..} = self;

        ChobitSexprBuf::<Car> {
            buffer: buffer,

            _marker: PhantomData::<Car>
        }
    }

    /// Drops and returns instance to be able to push list item.
    ///
    /// - _Return_ : ChobitSexprBuf that can push list item.
    #[inline]
    pub fn build_list(self) -> ChobitSexprBuf<List> {
        let Self {buffer, ..} = self;

        ChobitSexprBuf::<List> {
            buffer: buffer,

            _marker: PhantomData::<List>
        }
    }

    /// Drops and pushes sexpr and completes.
    ///
    /// - `sexpr` : Sexpr.
    /// - _Return_ : Comleted sexpr.
    #[inline]
    pub fn push_sexpr(self, sexpr: &ChobitSexpr) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(sexpr.as_bytes());

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }

    /// Drops and pushes atom and completes.
    ///
    /// - `value` : Payload of atom.
    /// - _Return_ : Completed sexpr.
    pub fn push_atom(self, value: &[u8]) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(
            &SexprHeader::new_atom(value.len()).to_bytes()
        );

        buffer.extend_from_slice(value);

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }

    /// Drops and returns nil sexpr.
    ///
    /// - _Return_ : Completed sexpr.
    pub fn push_nil(self) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(&SexprHeader::new_nil().to_bytes());

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }

    push_number!(push_i8, i8, push_number_doc!(i8));
    push_number!(push_u8, u8, push_number_doc!(u8));
    push_number!(push_i16, i16, push_number_doc!(i16));
    push_number!(push_u16, u16, push_number_doc!(u16));
    push_number!(push_i32, i32, push_number_doc!(i32));
    push_number!(push_u32, u32, push_number_doc!(u32));
    push_number!(push_i64, i64, push_number_doc!(i64));
    push_number!(push_u64, u64, push_number_doc!(u64));
    push_number!(push_i128, i128, push_number_doc!(i128));
    push_number!(push_u128, u128, push_number_doc!(u128));

    #[doc = push_number_doc!(f32)]
    #[inline]
    pub fn push_f32(self, value: f32) -> ChobitSexprBuf<Completed> {
        self.push_u32(value.to_bits())
    }

    #[doc = push_number_doc!(f64)]
    #[inline]
    pub fn push_f64(self, value: f64) -> ChobitSexprBuf<Completed> {
        self.push_u64(value.to_bits())
    }
}

impl ChobitSexprBuf<Completed> {
    /// Borrows self as immutable sexpr.
    ///
    /// - _Return_ : Self as immutable ChobitSexpr.
    #[inline]
    pub fn as_sexpr(&self) -> &ChobitSexpr {
        ChobitSexpr::new(self.buffer.as_slice())
    }

    /// Borrows self as mutable sexpr.
    ///
    /// - _Return_ : Self as mutable ChobitSexpr.
    #[inline]
    pub fn as_mut_sexpr(&mut self) -> &mut ChobitSexpr {
        ChobitSexpr::new_mut(self.buffer.as_mut_slice())
    }

    /// Drops self and returns buffer.
    ///
    /// - _Return_ : buffer.
    #[inline]
    pub fn drop_buffer(self) -> Vec<u8> {
        self.buffer
    }
}

impl ChobitSexprBuf<Car> {
    /// Drops and pushes car and returns instance to be able to push cdr.
    ///
    /// - `sexpr` : sexpr contained on car.
    /// - _Return_ : ChobitSexprBuf that can push cdr.
    pub fn push_car(self, sexpr: &ChobitSexpr) -> ChobitSexprBuf<Cdr> {
        let Self {mut buffer, ..} = self;

        let bytes = sexpr.as_bytes();

        buffer.extend_from_slice(
            &SexprHeader::new_cons(bytes.len()).to_bytes()
        );

        buffer.extend_from_slice(bytes);

        ChobitSexprBuf::<Cdr> {
            buffer: buffer,

            _marker: PhantomData::<Cdr>
        }
    }
}

impl ChobitSexprBuf<Cdr> {
    /// Drops and pushes car and completes.
    ///
    /// - `sexpr` : sexpr contained on car.
    /// - _Return_ : Completed sexpr.
    pub fn push_cdr(self, sexpr: &ChobitSexpr) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(sexpr.as_bytes());

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }
}

impl ChobitSexprBuf<List> {
    /// Drops and pushes list item and returns instance self.
    ///
    /// - `sexpr` : list item.
    /// - _Return_ : Instance that can push list item.
    pub fn push_item(self, sexpr: &ChobitSexpr) -> ChobitSexprBuf<List> {
        let Self {mut buffer, ..} = self;

        let bytes = sexpr.as_bytes();

        buffer.extend_from_slice(
            &SexprHeader::new_cons(bytes.len()).to_bytes()
        );

        buffer.extend_from_slice(bytes);

        ChobitSexprBuf::<List> {
            buffer: buffer,

            _marker: PhantomData::<List>
        }
    }

    /// Drops and pushes nil to cdr and completes.
    ///
    /// - _Return_ : Complete sexpr.
    pub fn finish(self) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(&SexprHeader::new_nil().to_bytes());

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }

    /// Drops and pushes sexpr to cdr and completes.
    ///
    /// - `sexpr` : Last sexpr.
    /// - _Return_ : Complete sexpr.
    pub fn finish_with(
        self,
        sexpr: &ChobitSexpr
    ) -> ChobitSexprBuf<Completed> {
        let Self {mut buffer, ..} = self;

        buffer.extend_from_slice(sexpr.as_bytes());

        ChobitSexprBuf::<Completed> {
            buffer: buffer,

            _marker: PhantomData::<Completed>
        }
    }
}

impl Default for ChobitSexprBuf<Empty> {
    #[inline]
    fn default() -> Self {
        ChobitSexprBuf::<Empty>::new()
    }
}

impl Deref for ChobitSexprBuf<Completed> {
    type Target = ChobitSexpr;

    #[inline]
    fn deref(&self) -> &ChobitSexpr {
        self.as_sexpr()
    }
}

impl DerefMut for ChobitSexprBuf<Completed> {
    #[inline]
    fn deref_mut(&mut self) -> &mut ChobitSexpr {
        self.as_mut_sexpr()
    }
}

impl AsRef<ChobitSexpr> for ChobitSexprBuf<Completed> {
    #[inline]
    fn as_ref(&self) -> &ChobitSexpr {
        self.as_sexpr()
    }
}

impl AsMut<ChobitSexpr> for ChobitSexprBuf<Completed> {
    #[inline]
    fn as_mut(&mut self) -> &mut ChobitSexpr {
        self.as_mut_sexpr()
    }
}

impl Borrow<ChobitSexpr> for ChobitSexprBuf<Completed> {
    #[inline]
    fn borrow(&self) -> &ChobitSexpr {
        self.as_sexpr()
    }
}

macro_rules! def_from {
    ($type:ty) => {
        impl From<$type> for ChobitSexprBuf<Completed> {
            #[inline]
            fn from(value: $type) -> Self {
                ChobitSexprBuf::new().push_atom(&value.to_le_bytes())
            }
        }
    };
}

def_from!(i8);
def_from!(u8);
def_from!(i16);
def_from!(u16);
def_from!(i32);
def_from!(u32);
def_from!(i64);
def_from!(u64);
def_from!(i128);
def_from!(u128);

impl From<f32> for ChobitSexprBuf<Completed> {
    #[inline]
    fn from(value: f32) -> Self {
        ChobitSexprBuf::<Completed>::from(value.to_bits())
    }
}

impl From<f64> for ChobitSexprBuf<Completed> {
    #[inline]
    fn from(value: f64) -> Self {
        ChobitSexprBuf::<Completed>::from(value.to_bits())
    }
}

impl From<&str> for ChobitSexprBuf<Completed> {
    #[inline]
    fn from(value: &str) -> Self {
        ChobitSexprBuf::new().push_atom(value.as_bytes())
    }
}
